<templateSet group="C/C++">
  <template name="lowest_common_ancestor" value="&#10;/**&#10; * @brief&#10; * 最小共通祖先（ダブリング）&#10; * 構築O(VlogV), クエリO(logV)&#10; *&#10; * LCA(G, root)で構築（無向木Gを、rootを根として向きづけしたときのLCAを構築）&#10; * query(u, v)で取得&#10; *&#10; * @author ゆきのん？&#10; * @date 2019/12&#10; */&#10;&#10;struct LCA {&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(nlog n)&#10;    * @param[in] G 無向木.&#10;    * @param[in] root 指定した根.&#10;    */&#10;    LCA(const vector&lt;vector&lt;int&gt;&gt;&amp; G, int root = 0) :&#10;            n(G.size()), log2_n(log2(n)), depth(n),&#10;            par(log2_n+1, vector&lt;int&gt;(n,-1)) {&#10;&#10;        dfs(G, root, -1, 0);&#10;&#10;        for (int k = 0; k &lt; log2_n; ++k) {&#10;            for (int v = 0; v &lt; n; ++v) {&#10;                if (par[k][v] != -1) {&#10;                    par[k+1][v] = par[k][par[k][v]];&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;    * @brief lca を取得する. O(log n);&#10;    * @param[in] u, v: lca を求めたい2頂点.&#10;    * @return u, v のlca.&#10;    */&#10;    int query(int u, int v) {&#10;        if (depth[u] &gt; depth[v]) swap(u, v);&#10;&#10;        for (int k = 0; k &lt;= log2_n; ++k) {&#10;            if ((depth[v] - depth[u]) &gt;&gt; k &amp; 1) {&#10;                v = par[k][v];&#10;            }&#10;        }&#10;        if (u == v) return u;&#10;&#10;        for (int k = log2_n; k &gt;= 0; --k) {&#10;            if (par[k][u] != par[k][v]) {&#10;                u = par[k][u];&#10;                v = par[k][v];&#10;            }&#10;        }&#10;        return par[0][u];&#10;    }&#10;&#10;private:&#10;    int n, log2_n;&#10;    vector&lt;int&gt; depth;&#10;    vector&lt;vector&lt;int&gt;&gt; par;&#10;&#10;    void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; G, int v, int p, int d) {&#10;        depth[v] = d;&#10;        par[0][v] = p;&#10;        for (auto to : G[v]) {&#10;            if (to != p) dfs(G, to, v, d+1);&#10;        }&#10;    }&#10;};&#10;" description="lowest_common_ancestor" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="topological_sort" value="&#10;void topological_sort(const vector&lt;vector&lt;int&gt;&gt;&amp; G, vector&lt;int&gt;&amp; ord)&#10;{&#10;    int n = G.size();&#10;    vector&lt;int&gt; num(n, 0);&#10;    ord.assign(n, 0);&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        for (auto u : G[i]) {&#10;            ++num[u];&#10;        }&#10;    }&#10;    stack&lt;int&gt; st;&#10;    for(int i = 0; i &lt; n; ++i) {&#10;        if (num[i] == 0) {&#10;            st.push(i);&#10;        }&#10;    }&#10;    for (int k = 0; !st.empty(); ++k) {&#10;        int i = st.top(); st.pop();&#10;        ord[k] = i;&#10;        for (auto u : G[i]) {&#10;            if (--num[u] == 0) {&#10;                st.push(u);&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="topological_sort" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="primal_dual" value="&#10;template&lt;typename flow_t, typename cost_t&gt;&#10;struct PrimalDual {&#10;    const cost_t INF;&#10;&#10;    struct edge {&#10;        int to;&#10;        flow_t cap;&#10;        cost_t cost;&#10;        int rev;&#10;    };&#10;    vector&lt;vector&lt;edge&gt;&gt; g;&#10;    vector&lt;cost_t&gt; h, d;&#10;    vector&lt;int&gt; prevv, preve;&#10;&#10;    PrimalDual(int V) : g(V), INF(numeric_limits&lt; cost_t &gt;::max()) {}&#10;&#10;    void add_edge(int from, int to, flow_t cap, cost_t cost) {&#10;        g[from].push_back({to, cap, cost, (int)g[to].size()});&#10;        g[to].push_back({from, 0, -cost, (int)g[from].size()-1});&#10;    }&#10;&#10;    cost_t min_cost_flow(int s, int t, flow_t f) {&#10;        int V = (int)g.size();&#10;        cost_t ret = 0;&#10;        using Pi = pair&lt;cost_t, int&gt;;&#10;        priority_queue&lt;Pi, vector&lt;Pi&gt;, greater&lt;Pi&gt;&gt; que;&#10;        h.assign(V, 0);&#10;        preve.assign(V, -1);&#10;        prevv.assign(V, -1);&#10;&#10;        while (f &gt; 0) {&#10;            d.assign(V, INF);&#10;            que.emplace(0, s);&#10;            d[s] = 0;&#10;            while (!que.empty()) {&#10;                Pi p = que.top(); que.pop();&#10;                if (d[p.second] &lt; p.first) continue;&#10;                for (int i = 0; i &lt; g[p.second].size(); i++) {&#10;                    edge &amp;e = g[p.second][i];&#10;                    cost_t nextCost = d[p.second] + e.cost +&#10;                        h[p.second] - h[e.to];&#10;                    if (e.cap &gt; 0 &amp;&amp; d[e.to] &gt; nextCost) {&#10;                        d[e.to] = nextCost;&#10;                        prevv[e.to] = p.second, preve[e.to] = i;&#10;                        que.emplace(d[e.to], e.to);&#10;                    }&#10;                }&#10;            }&#10;            if (d[t] == INF) return -1;&#10;            for (int v = 0; v &lt; V; v++) h[v] += d[v];&#10;            flow_t addflow = f;&#10;            for (int v = t; v != s; v = prevv[v]) {&#10;                addflow = min(addflow, g[prevv[v]][preve[v]].cap);&#10;            }&#10;            f -= addflow;&#10;            ret += addflow * h[t];&#10;            for (int v = t; v != s; v = prevv[v]) {&#10;                edge &amp;e = g[prevv[v]][preve[v]];&#10;                e.cap -= addflow;&#10;                g[v][e.rev].cap += addflow;&#10;            }&#10;        }&#10;        return ret;&#10;    }&#10;};&#10;" description="primal_dual" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="re_rooting" value="&#10;/**&#10; * @brief&#10; * 全方位木dp&#10; * @author habara-k&#10; * @date 2020/05/18&#10; * @verify https://codeforces.com/gym/102433/submission/80588275&#10; * @details 使い方&#10; *   e.g. 直径&#10; *   using T = pair&lt;int,int&gt;; // 頂点が持つべきデータ&#10; *   using Data = int;        // 親が子を引っ張り上げるときに必要なデータ&#10;&#10; *   ReRooting&lt;Data,T&gt; tr(&#10; *           n,&#10; *           [](T a, T b){&#10; *               vector&lt;int&gt; v{a.first,a.second,b.first,b.second};&#10; *               sort(v.rbegin(),v.rend());&#10; *               return T{v[0],v[1]};&#10; *               },                       // 子をマージする演算&#10; *           [](T a, Data w){&#10; *               return T{a.first+w, 0};&#10; *               },                       // 子を引っ張り上げる演算&#10; *           vector&lt;T&gt;(n, T{0, 0}),       // 頂点が持つデータの初期値&#10; *           T{0,0}                       // 子をマージする演算の単位元&#10; *           );&#10; *&#10; *   for (int i = 0; i &lt; n-1; ++i) {&#10; *       int s, t, w; cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;&#10; *       tr.add_edge(s, t, Data{w}, Data{w});&#10; *   }&#10; *&#10; *   auto ans = tr.solve();&#10; */&#10;&#10;template&lt;typename Data, typename T&gt;&#10;struct ReRooting {&#10;&#10;    using F1 = function&lt;T(T, T)&gt;;&#10;    using F2 = function&lt;T(T, Data)&gt;;&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(1).&#10;    * @param[in] n: 頂点数&#10;    * @param[in] f1: 子が持つデータをマージする演算&#10;    * @param[in] f2: 親が子を引っ張り上げる演算&#10;    * @param[in] init: 頂点が持つデータの初期値&#10;    * @param[in] ident: f1の単位元&#10;    */&#10;    ReRooting(&#10;            int n, const F1 &amp;f1, const F2 &amp;f2,&#10;            const vector&lt;T&gt; &amp;init, const T &amp;ident) :&#10;        g(n), ldp(n), rdp(n), lptr(n), rptr(n),&#10;        f1(f1), f2(f2), init(init), ident(ident) {}&#10;&#10;    /**&#10;    * @brief 辺を追加する. O(1)&#10;    * @param[in] u, v: 辺u, v を追加する.&#10;    * @param[in] d: u がv を引っ張り上げるときに必要なデータ.&#10;    * @param[in] e: v がu を引っ張り上げるときに必要なデータ.&#10;    */&#10;    void add_edge(int u, int v, const Data &amp;d, const Data &amp;e) {&#10;        g[u].emplace_back((edge){v, (int)g[v].size(), d});&#10;        g[v].emplace_back((edge){u, (int)g[u].size()-1, e});&#10;    }&#10;&#10;&#10;    /**&#10;    * @brief 全方位木dp を実行する.&#10;    * @return vector&lt;T&gt; 各頂点を根としたときの演算の結果.&#10;    */&#10;    vector&lt;T&gt; solve() {&#10;        for (int i = 0; i &lt; g.size(); ++i) {&#10;            ldp[i].assign(g[i].size()+1, ident);&#10;            rdp[i].assign(g[i].size()+1, ident);&#10;            lptr[i] = 0;&#10;            rptr[i] = (int)g[i].size()-1;&#10;            ldp[i][0] = init[i];&#10;        }&#10;        vector&lt;T&gt; ret(g.size());&#10;        for (int i = 0; i &lt; g.size(); ++i) {&#10;            ret[i] = dfs(i, -1);&#10;        }&#10;        return ret;&#10;    }&#10;&#10;private:&#10;    struct edge {&#10;        int to, rev;&#10;        Data data;&#10;    };&#10;&#10;    vector&lt;vector&lt;edge&gt;&gt; g;&#10;    vector&lt;vector&lt;T&gt;&gt; ldp, rdp;&#10;    vector&lt;int&gt; lptr, rptr;&#10;    const F1 f1;&#10;    const F2 f2;&#10;    const vector&lt;T&gt; init;&#10;    const T ident;&#10;&#10;    T dfs(int idx, int par) {&#10;        while (lptr[idx] != par and lptr[idx] &lt; g[idx].size()) {&#10;            auto &amp;e = g[idx][lptr[idx]];&#10;            ldp[idx][lptr[idx]+1] = f1(&#10;                    ldp[idx][lptr[idx]],&#10;                    f2(dfs(e.to, e.rev), e.data));&#10;            ++lptr[idx];&#10;        }&#10;        while (rptr[idx] != par and rptr[idx] &gt;= 0) {&#10;            auto &amp;e = g[idx][rptr[idx]];&#10;            rdp[idx][rptr[idx]] = f1(&#10;                    rdp[idx][rptr[idx]+1],&#10;                    f2(dfs(e.to, e.rev), e.data));&#10;            --rptr[idx];&#10;        }&#10;        if (par &lt; 0) return rdp[idx][0];&#10;        return f1(ldp[idx][par], rdp[idx][par+1]);&#10;    }&#10;};&#10;&#10;" description="re_rooting" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dijkstra" value="&#10;/**&#10; * @brief&#10; * 単一始点最短路(ダイクストラ)&#10; * 二分ヒープ(priority_queue)を使ってO((E+V)logV)&#10; * @author ?&#10; * @date 2019/12&#10; *&#10; * @param[in] g グラフ&#10; * @param[in] s 始点&#10; * @param[in] inf 到達不可能を表す無限値&#10; * @return vector&lt;T&gt; sからそれぞれの頂点への最短路&#10; *&#10; * @details&#10; * 2020/04/07 コメント追加、テスト有無のチェック by Md&#10; * 2020/05/04 inf に使う値を明示的に渡す. by haraba-k&#10; */&#10;&#10;template&lt;typename T&gt;&#10;vector&lt;T&gt; dijkstra(const Graph&lt;T&gt; &amp;g, int s, T inf) {&#10;    vector&lt;T&gt; d(g.size(), inf);&#10;&#10;    using Pi = pair&lt;T, int&gt;;&#10;    priority_queue&lt;Pi, vector&lt;Pi&gt;, greater&lt;Pi&gt;&gt; que;&#10;    d[s] = 0;&#10;    que.emplace(d[s], s);&#10;    while (!que.empty()) {&#10;        T cost;&#10;        int v;&#10;        tie(cost, v) = que.top();&#10;        que.pop();&#10;        if (d[v] &lt; cost) continue;&#10;        for (auto &amp;e : g[v]) {&#10;            auto nxt = cost + e.cost;&#10;            if (d[e.to] &gt; nxt) {&#10;                d[e.to] = nxt;&#10;                que.emplace(nxt, e.to);&#10;            }&#10;        }&#10;    }&#10;    return d;&#10;}&#10;" description="dijkstra" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="scc" value="&#10;template&lt;typename T&gt;&#10;struct SCC {&#10;    int sz, cnt, num;&#10;    vi post, comp;&#10;    vector&lt;pair&lt;int, int&gt;&gt; vp;&#10;    vector&lt;bool&gt; sel;&#10;    Graph&lt;T&gt; revg;&#10;&#10;    SCC(const Graph&lt;T&gt; &amp;g) {&#10;        sz = g.size();&#10;        cnt = 0;&#10;        num = 0;&#10;        post.resize(sz, -1);&#10;        comp.resize(sz, -1);&#10;        sel.resize(sz, false);&#10;        revg.resize(sz);&#10;    }&#10;&#10;    void build(const Graph&lt;T&gt; &amp;g) {&#10;        for(int i=0;i&lt;sz;++i) {&#10;            if(sel[i]) continue;&#10;            sel[i] = true;&#10;            dfs1(g, i);&#10;        }&#10;&#10;        rev(g, revg);&#10;&#10;        for(int i=0;i&lt;sz;++i) {&#10;            vp.emplace_back(make_pair(post[i], i));&#10;        }&#10;        sort(vp.begin(), vp.end());&#10;        reverse(vp.begin(), vp.end());&#10;        sel.clear();&#10;        sel.resize(sz, false);&#10;        for(int i=0;i&lt;sz;++i) {&#10;            if(sel[vp[i].second]) continue;&#10;            sel[vp[i].second] = true;&#10;            comp[vp[i].second] = num;&#10;            dfs2(revg, vp[i].second);&#10;            num++;&#10;        }&#10;    }&#10;&#10;    vi get_comp() {return comp;}&#10;&#10;    Graph&lt;T&gt; build_graph(const Graph&lt;T&gt; &amp;g) {&#10;        build(g);&#10;        vector&lt;set&lt;int&gt;&gt; s(sz);&#10;        Graph&lt;T&gt; res(sz);&#10;        for(int i=0;i&lt;sz;++i) {&#10;            for(int j=0;j&lt;(int)(g[i].size());++j) {&#10;                s[comp[i]].insert(comp[g[i][j].to]);&#10;            }&#10;        }&#10;        for(int i=0;i&lt;sz;++i) {&#10;            for(auto j: s[i]) {&#10;                if(i != j) res[i].push_back(edge&lt;int&gt;({i, j, 1}));&#10;            }&#10;        }&#10;        return res;&#10;    }&#10;&#10;    void dfs1(const Graph&lt;T&gt; &amp;g, int now) {&#10;        for(int i=0;i&lt;(int)(g[now].size());++i) {&#10;            int nxt = g[now][i].to;&#10;            if(sel[nxt]) continue;&#10;            sel[nxt] = true;&#10;            dfs1(g, nxt);&#10;        }&#10;        post[now] = cnt;&#10;        cnt++;&#10;    }&#10;&#10;    void rev(const Graph&lt;T&gt; &amp;g, Graph&lt;T&gt; &amp;revg) {&#10;        for(int i=0;i&lt;sz;++i) {&#10;            for(int j=0;j&lt;(int)(g[i].size());++j) {&#10;                revg[g[i][j].to].push_back({&#10;                        g[i][j].to, g[i][j].src, g[i][j].cost});&#10;            }&#10;        }&#10;    }&#10;&#10;    void dfs2(const Graph&lt;T&gt; &amp;revg, int now) {&#10;        for(int i=0;i&lt;(int)(revg[now].size());++i) {&#10;            int nxt = revg[now][i].to;&#10;            if(sel[nxt]) continue;&#10;            sel[nxt] = true;&#10;            comp[nxt] = num;&#10;            dfs2(revg, nxt);&#10;        }&#10;    }&#10;};&#10;" description="scc" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="hopcroft_karp" value="&#10;/**&#10; * @brief&#10; * HopcroftKarp(二部グラフの最大マッチング)&#10; * O(|E| sqrt(|V|))&#10; * |最大マッチング| + |最小辺カバー| = |V|&#10; * （二部グラフについて）|最大マッチング| = |最小点カバー|&#10; * |最大安定集合| + |最小点カバー| = |V|&#10; *&#10; * @author Md&#10; * @date 2019/12&#10; * @details&#10; * 2020/04/14 コメント追加 by Md&#10; */&#10;&#10;struct HopcroftKarp {&#10;    vector&lt;vector&lt;int&gt;&gt; g;&#10;    vector&lt;int&gt; d, mch;&#10;    vector&lt;bool&gt; used, vv;&#10;&#10;    HopcroftKarp(int n, int m) : g(n), mch(m, -1), used(n) {}&#10;&#10;    void add_edge(int u, int v) {&#10;        g[u].push_back(v);&#10;    }&#10;&#10;    void bfs() {&#10;        d.assign(g.size(), -1);&#10;        queue&lt;int&gt; que;&#10;        for (int i = 0; i &lt; (int)(g.size()); i++) {&#10;            if (!used[i]) {&#10;                que.emplace(i);&#10;                d[i] = 0;&#10;            }&#10;        }&#10;&#10;        while (!que.empty()) {&#10;            int a = que.front();&#10;            que.pop();&#10;            for (auto &amp;b : g[a]) {&#10;                int c = mch[b];&#10;                if (c &gt;= 0 &amp;&amp; d[c] == -1) {&#10;                    d[c] = d[a] + 1;&#10;                    que.emplace(c);&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    bool dfs(int a) {&#10;        vv[a] = true;&#10;        for (auto &amp;b : g[a]) {&#10;            int c = mch[b];&#10;            if (c &lt; 0 || (!vv[c] &amp;&amp; d[c] == d[a] + 1 &amp;&amp; dfs(c))) {&#10;                mch[b] = a;&#10;                used[a] = true;&#10;                return true;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    int bipartite_matching() {&#10;        int ret = 0;&#10;        while (true) {&#10;            bfs();&#10;            vv.assign(g.size(), false);&#10;            int flow = 0;&#10;            for (int i = 0; i &lt; (int)(g.size()); i++) {&#10;                if (!used[i] &amp;&amp; dfs(i)) ++flow;&#10;            }&#10;            if (flow == 0) return ret;&#10;            ret += flow;&#10;        }&#10;    }&#10;};&#10;" description="hopcroft_karp" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="bfs01" value="&#10;// verify: https://codeforces.com/contest/590/problem/C&#10;&#10;/**&#10; * @brief&#10; * 01-BFS&#10; * 辺の重みが01の時にO(E+V)で単一始点最短路をやる&#10; * @author Md&#10; * @date 2019/12&#10; * @param[in] g グラフ&#10; * @param[in] s 始点&#10; * @return vector&lt;T&gt; sからそれぞれの頂点への最短路&#10; * &#10; * @details&#10; * 2020/04/07&#10; * ソースコード修正、コメント追加、テスト追加 by Md&#10; * テストはdijkstraのものを流用(01-BFSでしか通らない問題、ある？)&#10; */&#10;&#10;template &lt;typename T&gt;&#10;std::vector&lt;T&gt; bfs01(const Graph&lt;T&gt; &amp;g, int s) {&#10;    const T INF = numeric_limits&lt;T&gt;::max();&#10;    std::vector&lt;T&gt; res(SZ(g), INF);&#10;    deque&lt;pair&lt;T, int&gt;&gt; deq;&#10;    res[s] = 0;&#10;    deq.push_back({0, s});&#10;    while(!deq.empty()) {&#10;        auto elm = deq.front(); deq.pop_front();&#10;        T cost = elm.first;&#10;        int now = elm.second;&#10;        if(cost &gt; res[now]) continue;&#10;&#10;        for(auto &amp;ne: g[now]) {&#10;            int nxt = ne.to;&#10;            if(res[nxt] &gt; cost + ne.cost) {&#10;                res[nxt] = cost + ne.cost;&#10;                if(ne.cost == 0) {&#10;                    deq.push_front({res[nxt], nxt});&#10;                } else {&#10;                    deq.push_back({res[nxt], nxt});&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    return res;&#10;}" description="bfs01" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lowlink" value="&#10;template&lt;typename T&gt;&#10;struct LowLink {&#10;    const int inf = 1000000000;&#10;    int sz;&#10;    std::vector&lt;int&gt; pre, low;&#10;    std::vector&lt;bool&gt; sel;&#10;    std::vector&lt;std::pair&lt;int, int&gt;&gt; bridge;&#10;    std::vector&lt;int&gt; articulation;&#10;&#10;    LowLink(const Graph&lt;T&gt; &amp;g) {&#10;        sz = g.size();&#10;        pre.resize(sz, inf);&#10;        low.resize(sz, inf);&#10;        sel.resize(sz, false);&#10;        int cnt = 0;&#10;        dfs(g, 0, -1, cnt);&#10;    }&#10;&#10;    void dfs(const Graph&lt;T&gt; &amp;g, int now, int prev, int &amp;cnt) {&#10;        if(pre[now] != inf) {&#10;            low[prev] = min(low[prev], pre[now]);&#10;            return;&#10;        }&#10;        pre[now] = cnt;&#10;        low[now] = cnt;&#10;        cnt++;&#10;        for(int i=0;i&lt;(int)(g[now].size());++i) {&#10;            int nxt = g[now][i].to;&#10;            //if g is an undirected graph&#10;            if(nxt == prev) continue;&#10;            dfs(g, nxt, now, cnt);&#10;        }&#10;        if(prev != -1) low[prev] = min(low[prev], low[now]);&#10;        if(prev != -1 &amp;&amp; pre[prev] &lt; low[now]) {&#10;            bridge.emplace_back(make_pair(prev, now));&#10;        }&#10;    }&#10;&#10;    void get_articulation(const Graph&lt;T&gt; &amp;g, int now, int prev) {&#10;        sel[now] = true;&#10;        int art = 0;&#10;        for(int i=0;i&lt;(int)(g[now].size());++i) {&#10;            int nxt = g[now][i].to;&#10;            //cout &lt;&lt; now &lt;&lt; &quot;:&quot; &lt;&lt; nxt &lt;&lt; endl;&#10;            if(sel[nxt]) continue;&#10;            // if g is an undirected graph&#10;            if(nxt == prev) continue;&#10;            if(now == 0 || pre[now] &lt;= low[nxt]) art++;&#10;            get_articulation(g, nxt, now);&#10;        }&#10;        if((now == 0 &amp;&amp; art &gt;= 2) || (now != 0 &amp;&amp; art &gt;= 1)) {&#10;            articulation.push_back(now);&#10;        }&#10;    }&#10;};&#10;" description="lowlink" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="kruskal" value="&#10;&#10;/**&#10; * @brief&#10; * クラスカル法（最小全域木）&#10; * O(|E|log|E|)&#10; * 大きさだけ求めてるけど構築もすぐ書けるはず（mergeのタイミングで登録）&#10; *&#10; * @author ?&#10; * @date 2019/12&#10; */&#10;&#10;template&lt;typename T&gt;&#10;T kruskal(vector&lt;edge&lt;T&gt;&gt; &amp;es, int V) {&#10;&#10;    UnionFind uf(V);&#10;    T ret = 0;&#10;&#10;    // sort destructively&#10;    sort(es.begin(), es.end(), [](edge&lt;T&gt; &amp;a,edge&lt;T&gt; &amp;b){&#10;            return a.cost &lt; b.cost;&#10;            });&#10;    for (auto &amp;e : es) {&#10;        if (!uf.issame(e.src, e.to)) {&#10;            ret += e.cost;&#10;            uf.merge(e.src, e.to);&#10;        }&#10;    }&#10;&#10;    // // sort only the order to check&#10;    // vector&lt;int&gt; ord(es.size());&#10;    // iota(ord.begin(), ord.end(), 0);&#10;    // sort(ord.begin(), ord.end(), [&amp;](int i,int j){&#10;    //         return es[i].cost &lt; es[j].cost;&#10;    //         });&#10;    // for (auto i : ord) {&#10;    //     auto &amp;e = es[i];&#10;    //     if (!uf.issame(e.src, e.to)) {&#10;    //         ret += e.cost;&#10;    //         uf.merge(e.src, e.to);&#10;    //     }&#10;    // }&#10;&#10;    return ret;&#10;}&#10;" description="kruskal" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="warshall_floyd" value="&#10;/**&#10; * @brief&#10; * 全点対間最短経路(ワーシャルフロイド)&#10; * O(V^3)&#10; * @author ?&#10; * @date ?&#10; *&#10; * @param[in] g グラフ(隣接行列)&#10; * @param[in] inf 到達不可能を表す無限値&#10; * @param[out] g 最短距離(隣接行列)&#10; *&#10; * @details&#10; * 2020/05/04 コメント追加, inf に使う値を明示的に渡す. by habara-k&#10; */&#10;&#10;template&lt;typename T&gt;&#10;void warshall_floyd(vector&lt;vector&lt;T&gt;&gt; &amp;g, T inf) {&#10;    int n = g.size();&#10;    for (int k = 0; k &lt; n; k++) {&#10;        for (int i = 0; i &lt; n; i++) {&#10;            for (int j = 0; j &lt; n; j++) {&#10;                if (g[i][k] == inf or g[k][j] == inf) continue;&#10;                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="warshall_floyd" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="maximum_clique" value="&#10;int maximum_clique(const vector&lt;vector&lt;bool&gt;&gt;&amp; G) {&#10;    // G: 隣接行列, 無向グラフ&#10;    int n = G.size();&#10;    vector&lt;int&gt; deg(n);&#10;    int M = 0;&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        for (int j = i+1; j &lt; n; ++j) {&#10;            ++deg[i], ++deg[j], ++M;&#10;        }&#10;    }&#10;    vector&lt;vector&lt;bool&gt;&gt; g = G;&#10;    vector&lt;bool&gt; used(n);&#10;&#10;    int lim = sqrt(2*M), ret = 0;&#10;&#10;    for (int t = 0; t &lt; n; ++t) {&#10;        int u = -1;&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            if (!used[i] &amp;&amp; deg[i] &lt; lim) {&#10;                u = i;&#10;                used[u] = true;&#10;                break;&#10;            }&#10;        }&#10;&#10;        vector&lt;int&gt; neighbor;&#10;        if (u != -1) neighbor.push_back(u);&#10;        for (int v = 0; v &lt; n; ++v) if (!used[v]) {&#10;            if (u == -1 || g[u][v]) {&#10;                neighbor.push_back(v);&#10;            }&#10;        }&#10;&#10;        int sz = neighbor.size();&#10;        vector&lt;int&gt; bit(sz);&#10;        for(int i = 0; i &lt; sz; i++) {&#10;            for(int j = i+1; j &lt; sz; j++) {&#10;                if(!g[neighbor[i]][neighbor[j]]) {&#10;                    bit[i] |= 1 &lt;&lt; j;&#10;                    bit[j] |= 1 &lt;&lt; i;&#10;                }&#10;            }&#10;        }&#10;&#10;        vector&lt;int&gt; dp(1&lt;&lt;sz);&#10;        dp[0] = 1;&#10;        for (int s = 1; s &lt; 1&lt;&lt;sz; ++s) {&#10;            int i = __builtin_ffs(s) - 1;&#10;&#10;            dp[s] = dp[s &amp; ~(1&lt;&lt;i)] &amp;&amp; (bit[i] &amp; s) == 0;&#10;            if (dp[s]) {&#10;                ret = max(ret, __builtin_popcount(s));&#10;            }&#10;        }&#10;&#10;        if (u == -1) break;&#10;&#10;        for (auto v : neighbor) {&#10;            --deg[v], --deg[u];&#10;            g[u][v] = g[v][u] = false;&#10;        }&#10;    }&#10;&#10;    return ret;&#10;}&#10;" description="maximum_clique" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dinic" value="&#10;/**&#10; * @brief&#10; * Dinic法(最大流)&#10; * 始点から終点までフローを流したときの最大流量を求める&#10; * O(EV^2) （だいたいもっとはやい）&#10; * @author Md&#10; * @date 2019/12&#10; * @detail&#10; * 2020/04/07 コメント追加 by Md&#10; * 構築したい&#10; */&#10;&#10;template &lt;typename T&gt;&#10;struct Dinic {&#10;  int sz;&#10;  T inf = numeric_limits&lt;T&gt;::max();&#10;  vector&lt;int&gt; level, iter;&#10;&#10;  struct Edge {&#10;    int to, rev;&#10;    T cap;&#10;    Edge(int to, int rev, T cap): to(to), rev(rev), cap(cap) {}&#10;  };&#10;  vector&lt;vector&lt;Edge&gt;&gt; g;&#10;&#10;  /**&#10;   * @brief コンストラクタ&#10;   * @param V 頂点数&#10;   */&#10;  Dinic(int V): sz(V) {&#10;    g.resize(V);&#10;    level.resize(V);&#10;    iter.resize(V);&#10;  };&#10;&#10;  /**&#10;   * @brief 辺を追加&#10;   * @param[in] from 始点&#10;   * @param[in] to 終点&#10;   * @param[in] cap 容量&#10;   */&#10;  void add_edge(int from, int to, T cap) {&#10;    g[from].emplace_back(to, (int)(g[to].size()), cap);&#10;    g[to].emplace_back(from, (int)(g[from].size())-1, 0);&#10;  }&#10;&#10;  /**&#10;   * @brief 最大流を求める&#10;   * @param[in] s 始点&#10;   * @param[in] t 終点&#10;   */&#10;  T max_flow(int s, int t) {&#10;    T flow = 0;&#10;    while(1) {&#10;      bfs(s);&#10;      if(level[t] &lt; 0) return flow;&#10;      iter.assign(sz, 0);&#10;      T f = dfs(s, t, inf);&#10;      while(f &gt; 0) {&#10;        flow += f;&#10;        f = dfs(s, t, inf);&#10;      }&#10;    }&#10;  }&#10;&#10;private:&#10;  void bfs(int s) {&#10;    level.assign(sz, -1);&#10;    level[s] = 0;&#10;    queue&lt;int&gt; que;&#10;    que.push(s);&#10;    while(!que.empty()) {&#10;      int now = que.front(); que.pop();&#10;      for(auto &amp;e: g[now]) {&#10;        if(e.cap &gt; 0 &amp;&amp; level[e.to] &lt; 0) {&#10;          level[e.to] = level[now] + 1;&#10;          que.push(e.to);&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  T dfs(int s, int t, T flow) {&#10;    if(s == t) return flow;&#10;    for(int i=iter[s];i&lt;(int)(g[s].size());++i) {&#10;      iter[s] = i;&#10;      auto e = g[s][i];&#10;      if(e.cap &gt; 0 &amp;&amp; level[s] &lt; level[e.to]) {&#10;        T d = dfs(e.to, t, min(flow, e.cap));&#10;        if(d &gt; 0) {&#10;          g[s][i].cap -= d;&#10;          g[e.to][e.rev].cap += d;&#10;          return d;&#10;        }&#10;      }&#10;    }&#10;    return 0;&#10;  }&#10;};" description="dinic" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="twoconnectedcomponents" value="&#10;template&lt;typename T&gt;&#10;struct TwoEdgeConnectedComponents: LowLink&lt;T&gt; {&#10;    using lowlink = LowLink&lt;T&gt;;&#10;    vector&lt;int&gt; comp;&#10;&#10;    TwoEdgeConnectedComponents(const Graph&lt;T&gt; &amp;g): lowlink(g) {}&#10;&#10;    int operator[] (const int &amp;k) {&#10;        return comp[k];&#10;    }&#10;&#10;    void dfs(int idx, int par, int &amp;k) {&#10;        if(!par &amp;&amp; this-&gt;pre[par] &gt;= this-&gt;low[idx]) comp[idx] = comp[par];&#10;        else comp[idx] == k++;&#10;        for(auto &amp;e: this-&gt;g[idx]) {&#10;            if(comp[e.to] == -1) dfs(e.to, idx, k);&#10;        }&#10;    }&#10;&#10;    void build(Graph&lt;T&gt; &amp;t) {&#10;        lowlink::build();&#10;        comp.assign(this-&gt;g.size(), -1);&#10;        int k = 0;&#10;        for(int i=0;i&lt;(int)(comp.size());++i) {&#10;            if(comp[i] == -1) dfs(i, -1, k);&#10;        }&#10;        t.resize(k);&#10;        for(auto &amp;e: this-&gt;bridge) {&#10;            int x = comp[e.first], y = comp[e.second];&#10;            t[x].push_back(y);&#10;            t[y].push_back(x);&#10;        }&#10;    }&#10;};" description="twoconnectedcomponents" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="heavy_light_decomposition" value="&#10;/**&#10;* @brief HL分解&#10;* @author habara-k&#10;* @date 2020/04/26&#10;* @details 使い方&#10;*   vector&lt;vector&lt;int&gt;&gt; g(n); // tree&#10;*&#10;*   HLDecomposition hld(g);&#10;*   hld.build(); // 必ずbuildする!&#10;*/&#10;&#10;struct HLDecomposition {&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(|V|).&#10;    * @param[in] g HL分解する木.&#10;    */&#10;    HLDecomposition(const vector&lt;vector&lt;int&gt;&gt;&amp; g) :&#10;        g(g), par(g.size()), size(g.size()), depth(g.size()),&#10;        head(g.size()), vid(g.size()) {}&#10;&#10;    /**&#10;    * @brief HL分解を行う. O(|V|).&#10;    * @param[in] root 根を指定する. デフォルトは0&#10;    */&#10;    void build(int root = 0) {&#10;        dfs(root, -1, 0);&#10;        int k = 0;&#10;        hld(root, root, k);&#10;    }&#10;&#10;    /**&#10;    * @brief HL分解を行う. O(log|V|).&#10;    * @param[in] u, v lcaを求めたい2頂点&#10;    * @return 2頂点u, v のlca&#10;    */&#10;    int lca(int u, int v) const {&#10;        for (;; v = par[head[v]]) {&#10;            if (depth[head[u]] &gt; depth[head[v]]) swap(u, v);&#10;            if (head[u] == head[v]) {&#10;                if (depth[u] &gt; depth[v]) swap(u, v);&#10;                return u;&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した2頂点間のパス上で更新クエリを実行する. O(log|V|) * O(q).&#10;    * @param[in] u, v 更新クエリを実行するパスの両端.&#10;    * @param[in] q 実行する更新クエリ.&#10;    * @param[in] edge 辺クエリか頂点クエリか. デフォルトは頂点クエリ.&#10;    *   辺クエリ:&#10;    *     木上の辺に対してクエリを処理する.&#10;    *     辺のデータは子頂点のindexに対応している.&#10;    *     親頂点のindexに対応する辺は無い.&#10;    *   頂点クエリ:&#10;    *     木上の頂点に対してクエリを処理する.&#10;    *&#10;    * @details 使い方&#10;    *     e.g. Range Update Query&#10;    *     LazySegmentTree&lt;int&gt; segt;&#10;    *            // 木に対応する遅延セグメント木.&#10;    *            // 木の頂点がそのままsegtのindexになるわけでは無いので注意.&#10;    *     int u, v, x;&#10;    *            // u, v 間のパス上にある全ての頂点の値をx に変更したい.&#10;    *     hld.update(u, v, [&amp;](int s,int t){ segt.update(s, t, x); });&#10;    *            // u, v 間のパスを小分けにした区間全体に&#10;    *            // 第三引数の関数が実行される.&#10;    */&#10;    template&lt;class UpdateQuery&gt;&#10;    void update(int u, int v, const UpdateQuery&amp; q, bool edge = false) const {&#10;        for (;; v = par[head[v]]) {&#10;            if (depth[head[u]] &gt; depth[head[v]]) swap(u, v);&#10;            if (head[u] == head[v]) {&#10;                if (vid[u] &gt; vid[v]) swap(u, v);&#10;                q(vid[u] + edge, vid[v] + 1);&#10;                break;&#10;            } else {&#10;                q(vid[head[v]], vid[v] + 1);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した2頂点間のパス上で取得クエリを実行. O(log|V|) * (O(q)+O(f)).&#10;    * @param[in] u, v 取得クエリを実行するパスの両端.&#10;    * @param[in] q 実行する取得クエリ.&#10;    * @param[in] f 小分けにした区間から取得した値をマージする方法.&#10;    * @param[in] ident fの単位元.&#10;    * @param[in] edge 辺クエリか頂点クエリか. デフォルトは頂点クエリ.&#10;    * @return 取得した値.&#10;    *&#10;    * @details 使い方&#10;    *     e.g. Range Minimum Query&#10;    *     SegmentTree&lt;int&gt; segt;&#10;    *            // 木に対応するセグメント木.&#10;    *            // 木の頂点がそのままsegtのindexになるわけでは無いので注意.&#10;    *     int u, v;&#10;    *            // u, v 間のパス上にある全ての頂点の値のminを取得したい.&#10;    *     hld.query(u, v,&#10;    *          [&amp;](int s,int t){ return segt.query(s,t); },&#10;    *          [&amp;](int a,int b){ return min(a,b); }, INF);&#10;    *            // u, v 間のパスを小分けにした区間全体に&#10;    *            // 第三引数の関数が実行される.&#10;    *            // 各区間から取得した値は, 第四引数の関数によってマージされる.&#10;    *            // minの単位元INFを第五引数に渡す.&#10;    */&#10;    template&lt;class Query, class MergeFunc, typename T&gt;&#10;    T query(int u, int v,&#10;            const Query&amp; q, const MergeFunc&amp; f,&#10;            const T&amp; ident, bool edge = false) const {&#10;        T ret = ident;&#10;        for (;; v = par[head[v]]) {&#10;            if (depth[head[u]] &gt; depth[head[v]]) swap(u, v);&#10;            if (head[u] == head[v]) {&#10;                if (vid[u] &gt; vid[v]) swap(u, v);&#10;                return f(ret, q(vid[u] + edge, vid[v] + 1));&#10;            } else {&#10;                ret = f(ret, q(vid[head[v]], vid[v] + 1));&#10;            }&#10;        }&#10;    }&#10;&#10;private:&#10;    const vector&lt;vector&lt;int&gt;&gt;&amp; g;&#10;    vector&lt;int&gt; par, size, depth, head, vid;&#10;    // par[v] := 頂点v の親頂点.&#10;    // size[v] := 頂点v を根とした部分木の頂点数.&#10;    // depth[v] := 頂点v の深さ. 根の深さは0.&#10;    // head[v] := HL分解した際に, 頂点v を含む区間の先頭に位置する頂点.&#10;    // vid[v] := 頂点v に対応する内部index.&#10;    //           HL分解した後の各区間上で, vidは連続している.&#10;&#10;    void dfs(int v, int p, int d) {&#10;        par[v] = p; depth[v] = d; size[v] = 1;&#10;        for (int u : g[v]) {&#10;            if (u == p) continue;&#10;            dfs(u, v, d+1);&#10;            size[v] += size[u];&#10;        }&#10;    }&#10;    void hld(int v, int h, int&amp; k) {&#10;        head[v] = h; vid[v] = k++;&#10;        int ma = 0, id = -1;&#10;        for (int u : g[v]) {&#10;            if (u == par[v]) continue;&#10;            if (chmax(ma, size[u])) id = u;&#10;        }&#10;        if (id == -1) return;&#10;        hld(id, h, k);&#10;        for (int u : g[v]) {&#10;            if (u == id or u == par[v]) continue;&#10;            hld(u, u, k);&#10;        }&#10;    }&#10;};&#10;" description="heavy_light_decomposition" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="2D_template" value="&#10;/**&#10; * @brief&#10; * 二次元幾何&#10; * @author habara-k&#10; * @date 2020/05/05&#10; */&#10;&#10;// template {{{&#10;&#10;using Real = double;&#10;const Real PI = acos(-1);&#10;&#10;using Point = complex&lt;Real&gt;;&#10;namespace std {&#10;    bool operator&lt;(const Point&amp; a, const Point&amp; b) {&#10;        if (a.real() == b.real()) return a.imag() &lt; b.imag();&#10;        return a.real() &lt; b.real();&#10;    }&#10;}&#10;&#10;struct Line {&#10;    Point a, b;&#10;    Line() {}&#10;    Line(const Point&amp; a, const Point&amp; b) : a(a), b(b) {}&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Line&amp; l) {&#10;        return os &lt;&lt; &quot;[&quot; &lt;&lt; l.a &lt;&lt; &quot;,&quot; &lt;&lt; l.b &lt;&lt; &quot;]&quot;;&#10;    }&#10;};&#10;&#10;struct Segment : Line {&#10;    Segment() {}&#10;    // Segment() = default;&#10;&#10;    Segment(const Point&amp; a, const Point&amp; b) : Line(a, b) {}&#10;};&#10;&#10;inline bool eq(Real a, Real b) { return abs(b - a) &lt; eps; }&#10;&#10;// }}}&#10;&#10;&#10;// utils {{{&#10;&#10;Real radian_to_degree(Real r) {&#10;    return r * 180.0 / PI;&#10;}&#10;&#10;Real degree_to_radian(Real d) {&#10;    return d * PI / 180.0;&#10;}&#10;&#10;Point rotate(const Point &amp;p, Real theta) {&#10;    return p * polar((Real)1.0, theta);&#10;}&#10;&#10;Real cross(const Point&amp; a, const Point&amp; b) {&#10;    return a.real() * b.imag() - a.imag() * b.real();&#10;}&#10;&#10;Real dot(const Point&amp; a, const Point&amp; b) {&#10;    return a.real() * b.real() + a.imag() * b.imag();&#10;}&#10;&#10;// }}}&#10;&#10;&#10;/**&#10;* @brief 点p の直線l への射影を求める.&#10;*/&#10;Point projection(const Line&amp; l, const Point&amp; p) {&#10;    Real A = dot(l.b - l.a, p - l.a),&#10;         B = dot(l.a - l.b, p - l.b);&#10;    return (A * l.b + B * l.a) / (A + B);&#10;}&#10;&#10;/**&#10;* @brief 2直線の並行判定&#10;*/&#10;bool parallel(const Line&amp; l1, const Line&amp; l2) {&#10;    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);&#10;}&#10;&#10;/**&#10;* @brief 2直線の直行判定&#10;*/&#10;bool orthogonal(const Line&amp; l1, const Line&amp; l2) {&#10;    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);&#10;}&#10;&#10;&#10;/**&#10;* @brief 有向線分と点の位置関係&#10;* @param[in] a, b, c: 線分a-&gt;b, 点c&#10;* @return 線分a-&gt;b からみて, 点c がどこにあるか.&#10;*/&#10;const int COUNTER_CLOCKWISE = 1,&#10;          CLOCKWISE = -1,&#10;          ONLINE_BACK = 2,&#10;          ONLINE_FRONT = -2,&#10;          ON_SEGMENT = 0;&#10;int ccw(const Point&amp; a, Point b, Point c) {&#10;    b = b - a, c = c - a;&#10;    if (cross(b, c) &gt; eps) return COUNTER_CLOCKWISE;&#10;    if (cross(b, c) &lt; -eps) return CLOCKWISE;&#10;    if (dot(b, c) &lt; 0) return ONLINE_BACK;&#10;    if (norm(b) &lt; norm(c)) return ONLINE_FRONT;&#10;    return ON_SEGMENT;&#10;}&#10;&#10;&#10;// 交差 {{{&#10;&#10;/**&#10;* @brief 直線と点の交差判定&#10;*/&#10;bool intersected(const Line&amp; l, const Point&amp; p) {&#10;    return abs(ccw(l.a, l.b, p)) != 1;&#10;}&#10;&#10;/**&#10;* @brief 線分と点の交差判定&#10;*/&#10;bool intersected(const Segment&amp; s, const Point&amp; p) {&#10;    return ccw(s.a, s.b, p) == 0;&#10;}&#10;&#10;/**&#10;* @brief 直線と線分の交差判定&#10;*/&#10;bool intersected(const Line&amp; l, const Segment&amp; s) {&#10;    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) &lt; eps;&#10;}&#10;&#10;/**&#10;* @brief 2つの線分の交差判定&#10;*/&#10;bool intersected(const Segment&amp; s1, const Segment&amp; s2) {&#10;    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) &lt;= 0 and&#10;           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) &lt;= 0;&#10;}&#10;&#10;&#10;/**&#10;* @brief 2直線の交点&#10;*/&#10;Point crosspoint(const Line&amp; l1, const Line&amp; l2) {&#10;    Real A = cross(l2.a - l1.a, l2.b - l1.a),&#10;         B = cross(l2.b - l1.b, l2.a - l1.b);&#10;    return (A * l1.b + B * l1.a) / (A + B);&#10;}&#10;&#10;// }}}&#10;&#10;&#10;// 距離 {{{&#10;&#10;/**&#10;* @brief 直線と点の距離&#10;*/&#10;Real distance(const Line&amp; l, const Point&amp; p) {&#10;    return abs(p - projection(l, p));&#10;}&#10;&#10;/**&#10;* @brief 線分と点の距離&#10;*/&#10;Real distance(const Segment&amp; s, const Point&amp; p) {&#10;    Point r = projection(s, p);&#10;    if (intersected(s, r)) return abs(r - p);&#10;    return min(abs(s.a - p), abs(s.b - p));&#10;}&#10;&#10;/**&#10;* @brief 直線と線分の距離&#10;*/&#10;Real distance(const Line &amp;l, const Segment &amp;s) {&#10;    if (intersected(l, s)) return 0;&#10;    return min(distance(l, s.a), distance(l, s.b));&#10;}&#10;&#10;/**&#10;* @brief 2つの線分の距離&#10;*/&#10;Real distance(const Segment&amp; s1, const Segment&amp; s2) {&#10;    if (intersected(s1, s2)) return 0.0;&#10;    return min({ distance(s1, s2.a), distance(s1, s2.b),&#10;                 distance(s2, s1.a), distance(s2, s1.b) });&#10;}&#10;&#10;// }}}&#10;&#10;&#10;&#10;// 円 {{{&#10;&#10;struct Circle {&#10;    Point p;&#10;    Real r;&#10;    Circle() {}&#10;    Circle(const Point&amp; p, Real r) : p(p), r(r) {}&#10;};&#10;&#10;&#10;/**&#10;* @brief 2つの円の交点の数&#10;*/&#10;int intersected(Circle c1, Circle c2) {&#10;    if (c1.r &lt; c2.r) swap(c1, c2);&#10;    Real d = abs(c1.p - c2.p);&#10;    if (c1.r + c2.r &lt; d) return 4;&#10;    if (eq(c1.r + c2.r, d)) return 3;&#10;    if (c1.r - c2.r &lt; d) return 2;&#10;    if (eq(c1.r - c2.r, d)) return 1;&#10;    return 0;&#10;}&#10;&#10;/**&#10;* @brief 円と直線の交点のペア&#10;* @details 交差することを確認してから呼ぶこと.&#10;*/&#10;pair&lt;Point,Point&gt; crosspoint(const Circle&amp; c, const Line&amp; l) {&#10;    Real h = distance(l, c.p);&#10;    Point p = projection(l, c.p);&#10;    if (eq(h, c.r)) return { p, p };&#10;    Point u = l.a - l.b; u /= abs(u);&#10;    Real d = sqrt(c.r * c.r - h * h);&#10;    return { p + u * d, p - u * d };&#10;}&#10;&#10;/**&#10;* @brief 2つの円の交点のペア&#10;* @details 交差することを確認してから呼ぶこと.&#10;*/&#10;pair&lt;Point,Point&gt; crosspoint(const Circle&amp; c1, const Circle&amp; c2) {&#10;    Real d = abs(c2.p - c1.p), t = arg(c2.p - c1.p);&#10;    Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));&#10;    return { c1.p + polar(c1.r, t + a),&#10;             c1.p + polar(c1.r, t - a) };&#10;}&#10;&#10;/**&#10;* @brief 点p, 円c に対し, pを通るcの接線を返す(c上の2点のペアで返す).&#10;* @details 点p が円c の外側にあることを確認してから呼ぶこと.&#10;*/&#10;pair&lt;Point,Point&gt; tangent(const Point&amp; p, const Circle&amp; c) {&#10;    return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));&#10;};&#10;&#10;/**&#10;* @brief 2つの円に共通する接線を返す(最大4本).&#10;* @details 点p が円c の外側にあることを確認してから呼ぶこと.&#10;*/&#10;vector&lt;Line&gt; common_tangent(const Circle&amp; c1, const Circle&amp; c2) {&#10;    vector&lt;Line&gt; lines;&#10;    Point u = c2.p - c1.p;&#10;    Real d = abs(u);&#10;    if (eq(d, 0.0)) return lines;&#10;    u /= d;&#10;    for (Real s : { -1, 1 }) {&#10;        // s = -1: 同じ側に2つの円があるとき.&#10;        // s =  1: 反対側に2つの円があるとき.&#10;        Real h = (c1.r + s * c2.r) / d;&#10;        if (eq(abs(h), 1.0)) {&#10;            // 2つの円が接しているとき.&#10;            lines.emplace_back(&#10;                    c1.p + u * h * c1.r,&#10;                    c1.p + u * h * c1.r + rotate(u, PI / 2.0));&#10;        } else if (abs(h) &lt; 1) {&#10;            // 2本の接線が引けるとき.&#10;            Real a = acos(h);&#10;            lines.emplace_back(&#10;                    c1.p + u * polar(c1.r, a),&#10;                    c2.p - s * u * polar(c2.r, a));&#10;            lines.emplace_back(&#10;                    c1.p + u * polar(c1.r, -a),&#10;                    c2.p - s * u * polar(c2.r, -a));&#10;        }&#10;    }&#10;    return lines;&#10;}&#10;&#10;// }}}&#10;" description="2D_template" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="polygon" value="&#10;/**&#10; * @brief&#10; * 多角形&#10; * @author habara-k&#10; * @date 2020/05/05&#10; */&#10;&#10;// template {{{&#10;&#10;using Polygon = vector&lt;Point&gt;;&#10;&#10;// }}}&#10;&#10;&#10;/**&#10;* @brief 符号付き面積を求める(反時計回りで正).&#10;*/&#10;Real area(const Polygon&amp; U) {&#10;    Real area = 0;&#10;    for (int i = 0; i &lt; U.size(); ++i) {&#10;        area += cross(U[i], U[(i + 1) % U.size()]);&#10;    }&#10;    return area / 2.0;&#10;}&#10;&#10;/**&#10;* @brief 凸判定&#10;* @details 頂点は反時計回りで与えること.&#10;*/&#10;bool is_convex(const Polygon &amp;U) {&#10;    int n = U.size();&#10;    for (int i = 0; i &lt; n; ++i) {&#10;        if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;&#10;    }&#10;    return true;&#10;}&#10;&#10;/**&#10;* @brief 点の内部判定&#10;*/&#10;const int OUT = 0,&#10;          ON = 1,&#10;          IN = 2;&#10;int contains(const Polygon &amp;U, const Point &amp;p) {&#10;    int in = 0;&#10;    for (int i = 0; i &lt; U.size(); ++i) {&#10;        Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;&#10;        if (cross(a, b) == 0 and dot(a, b) &lt;= 0) return ON;&#10;        if (a.imag() &gt; b.imag()) swap(a, b);&#10;        if (a.imag() &lt;= 0 and 0 &lt; b.imag() and cross(a, b) &lt; 0) in ^= 1;&#10;    }&#10;    return in ? IN : OUT;&#10;}&#10;&#10;/**&#10;* @brief 凸包&#10;* @param[in] includeOnLine: 凸包の辺上に位置する点も欲しいときにtrue にする.&#10;* @return 凸包上の頂点(反時計回り).&#10;*/&#10;vector&lt;Point&gt; convex_hull(vector&lt;Point&gt;&amp; p, bool includeOnLine = false) {&#10;    int n = p.size(), k = 0;&#10;    if (n &lt;= 2) return p;&#10;    sort(p.begin(), p.end(), [](Point&amp; a, Point&amp; b) {&#10;            if (a.real() == b.real()) return a.imag() &lt; b.imag();&#10;            return a.real() &lt; b.real();&#10;            });&#10;    vector&lt;Point&gt; ch(n * 2);&#10;    const Real BOUND = includeOnLine ? -eps : eps;&#10;    for (int i = 0; i &lt; n; ch[k++] = p[i++]) {&#10;        while (k &gt;= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) &lt; BOUND) --k;&#10;    }&#10;    for (int i = n-2, t = k+1; i &gt;= 0; ch[k++] = p[i--]) {&#10;        while (k &gt;= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) &lt; BOUND) --k;&#10;    }&#10;    ch.resize(k-1);&#10;    return ch;&#10;}&#10;&#10;/**&#10;* @brief 凸多角形の直径&#10;*/&#10;Real convex_diameter(const Polygon &amp;U) {&#10;    int n = U.size();&#10;    int is = 0, js = 0;&#10;    for (int i = 1; i &lt; n; ++i) {&#10;        if (U[i].imag() &gt; U[is].imag()) is = i;&#10;        if (U[i].imag() &lt; U[js].imag()) js = i;&#10;    }&#10;    Real maxnorm = norm(U[is] - U[js]);&#10;&#10;    int i = is, j = js;&#10;    do {&#10;        if (cross(U[(i+1) % n] - U[i], U[(j+1) % n] - U[j]) &gt;= 0) {&#10;            j = (j+1) % n;&#10;        } else {&#10;            i = (i+1) % n;&#10;        }&#10;        if (norm(U[i] - U[j]) &gt; maxnorm) {&#10;            maxnorm = norm(U[i] - U[j]);&#10;        }&#10;    } while (i != is or j != js);&#10;    return sqrt(maxnorm);&#10;}&#10;&#10;/**&#10;* @brief 凸カット&#10;* @param[in] U: カットしたい凸多角形&#10;* @param[in] l: カットに用いる直線&#10;* @return 直線l.a-&gt;l.b からみて反時計回り側の凸多角形を返す(入力と同じ回り順).&#10;*/&#10;Polygon convex_cut(const Polygon&amp; U, const Line&amp; l) {&#10;    Polygon ret;&#10;    for (int i = 0; i &lt; U.size(); ++i) {&#10;        Point now = U[i], nxt = U[(i + 1) % U.size()];&#10;        if (ccw(l.a, l.b, now) != -1) ret.push_back(now);&#10;        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) == -1) {&#10;            ret.push_back(crosspoint(Line{ now, nxt }, l));&#10;        }&#10;    }&#10;    return ret;&#10;}&#10;" description="polygon" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="inversion" value="&#10;&#10;template&lt;typename T&gt;&#10;ll inversion(const vector&lt;T&gt;&amp; a)&#10;{&#10;    map&lt;T,int&gt; mp;&#10;    for (auto e : a) mp[e] = -1;&#10;    int sz = 0;&#10;    for (auto &amp;q : mp) {&#10;        q.second = sz++;&#10;    }&#10;&#10;    BIT&lt;int&gt; bit(sz+1);&#10;    ll res = 0;&#10;    for (int i = 0; i &lt; a.size(); ++i) {&#10;        res += i - bit.sum(mp[a[i]]);&#10;        bit.add(mp[a[i]], 1);&#10;    }&#10;    return res;&#10;}&#10;" description="inversion" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="dice" value="&#10;// 0: 上, 1: 手前, 2: 左, 3: 奥, 4: 右, 5: 下&#10;struct Dice {&#10;  vi face;&#10;  void init() {&#10;    face.resize(6);&#10;  }&#10;&#10;  // 左に転がす&#10;  void rotl() {&#10;    vi newface = {face[4], face[1], face[0], face[3], face[5], face[2]};&#10;    swap(face, newface);&#10;  }&#10;&#10;  // 右に転がす&#10;  void rotr() {&#10;    vi newface = {face[2], face[1], face[5], face[3], face[0], face[4]};&#10;    swap(face, newface);&#10;  }&#10;&#10;  // 奥に転がす&#10;  void rotu() {&#10;    vi newface = {face[1], face[5], face[2], face[0], face[4], face[3]};&#10;    swap(face, newface);&#10;  }&#10;&#10;  // 手前に転がす&#10;  void rotd() {&#10;    vi newface = {face[3], face[0], face[2], face[5], face[4], face[1]};&#10;    swap(face, newface);&#10;  }&#10;};&#10;&#10;bool operator==(Dice d1, Dice d2) {&#10;  return d1.face == d2.face;&#10;}&#10;&#10;bool operator&lt;(Dice d1, Dice d2) {&#10;  return d1.face &lt; d2.face;&#10;}" description="dice" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="LIS" value="&#10;template&lt;typename T&gt;&#10;int LIS(const vector&lt;T&gt;&amp; a) {&#10;    int n = a.size();&#10;    T INF = numeric_limits&lt;T&gt;::max();&#10;    vector&lt;T&gt; dp(n, INF);&#10;    for(int i = 0; i &lt; n; ++i) {&#10;        *lower_bound(dp.begin(), dp.end(), a[i]) = a[i];&#10;    }&#10;    return distance(dp.begin(), lower_bound(dp.begin(), dp.end(), INF));&#10;}&#10;" description="LIS" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="combination" value="&#10;vector&lt;ll&gt; fact;&#10;void init_fact(int n, ll m) {&#10;    fact.assign(n+1, 1);&#10;    for (int i = 2; i &lt;= n; ++i) {&#10;        (fact[i] = fact[i-1] * i) %= m;&#10;    }&#10;}&#10;&#10;// require init_fact(GREATER THAN OR EQUAL TO n, m)&#10;ll C(ll n, ll r, ll m) {&#10;    return (fact[n] * invm((fact[r] * fact[n-r]) % m, m)) % m;&#10;}&#10;&#10;// Stirling number&#10;// Stirling(n, k) := the number of cases&#10;//            to split n balls(distinguished)&#10;//            into k boxes(not distinguished)&#10;//            s.t. each box contains at least one ball.&#10;//&#10;// require init_fact(GREATER THAN OR EQUAL TO k, m)&#10;ll Stirling(ll n, ll k, ll m) {&#10;    ll ret = 0;&#10;    for (ll l = 0; l &lt;= k; ++l) {&#10;        ll tmp = (C(k, l, m) * powm((k-l) % m, n, m)) % m;&#10;        if (l &amp; 1) tmp = (-tmp + m) % m;&#10;        (ret += tmp) %= m;&#10;    }&#10;    return (ret *= invm(fact[k], m)) %= m;&#10;}&#10;&#10;// Bell number&#10;// Bell(n, k) := the number of cases&#10;//            to split n balls(distinguished)&#10;//            into k boxes(not distinguished)&#10;//&#10;// require init_fact(GREATER THAN OR EQUAL TO k, m)&#10;ll Bell(ll n, ll k, ll m) {&#10;    ll ret = 0;&#10;    for (ll l = 0; l &lt;= k; ++l) {&#10;        (ret += Stirling(n, l, m)) %= m;&#10;    }&#10;    return ret;&#10;}&#10;&#10;// Partition function&#10;// Partition[k][n] := the number of cases&#10;//            to split n balls(not distinguished)&#10;//            into k boxes(not distinguished)&#10;vector&lt;vector&lt;ll&gt;&gt; Part;&#10;void init_partition(ll k, ll n, ll m) {&#10;    Part.assign(k+1, vector&lt;ll&gt;(n+1, 0));&#10;    Part[0][0] = 1;&#10;    for (int i = 1; i &lt;= k; ++i) {&#10;        for (int j = 0; j &lt;= n; ++j) {&#10;            if (j-i &gt;= 0) {&#10;                Part[i][j] = (Part[i-1][j] + Part[i][j-i]) % m;&#10;            } else {&#10;                Part[i][j] = Part[i-1][j];&#10;            }&#10;        }&#10;    }&#10;}&#10;" description="combination" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="extended_gcd" value="&#10;ll extended_gcd(ll a, ll b, ll&amp; x, ll&amp; y) {&#10;    // solve ax + by = gcd(a, b)&#10;    if (b == 0) { x = 1; y = 0; return a; }&#10;    ll X, Y;&#10;    ll g = extended_gcd(b, a % b, X, Y);&#10;    x = Y; y = X - a/b * Y;&#10;    return g;&#10;}&#10;" description="extended_gcd" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="mod" value="&#10;ll powm(ll a, ll n, ll m) {&#10;    ll ret = 1;&#10;    while (n &gt; 0) {&#10;        if (n &amp; 1) (ret *= a) %= m;&#10;        (a *= a) %= m;&#10;        n &gt;&gt;= 1;&#10;    }&#10;    return ret;&#10;}&#10;&#10;ll invm(ll a, ll m) {&#10;    return powm(a, m-2, m);&#10;}&#10;&#10;&#10;/**&#10; * @brief&#10; * 離散対数 O(sqrt(m))&#10; * @author habara-k&#10; * @date 2020/05/18&#10; * @verify https://atcoder.jp/contests/arc042/submissions/13372745&#10; *&#10; * @param[in] a: 0 &lt; a &lt; m&#10; * @param[in] b: 0 &lt;= b &lt; m&#10; * @param[in] m: prime&#10; * @return:&#10; *     minimum x &gt;= 0 s.t. a^x == b mod m&#10; *     if no x satisfies the condition, return -1&#10; */&#10;&#10;ll logm(ll a, ll b, ll m) {&#10;&#10;    ll sm = sqrt(m);&#10;&#10;    map&lt;ll,int&gt; mp;&#10;    for (ll t = 1, r = 0; r &lt; sm; (t *= a) %= m, ++r) {&#10;        if (!mp.count(t)) mp[t] = r;&#10;    }&#10;&#10;    ll A = invm(powm(a, sm, m), m);&#10;    for (ll t = b, p = 0; p &lt;= sm; (t *= A) %= m, ++p) {&#10;        if (mp.count(t)) {&#10;            return sm * p + mp[t];&#10;        }&#10;    }&#10;    return -1;&#10;}&#10;" description="mod" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="fft" value="&#10;/**&#10;* @brief FFT&#10;* @author habara-k&#10;* @date 2020/05/27&#10;* @verify https://atcoder.jp/contests/atc001/submissions/13627626&#10;* @details 使い方&#10;*   e.g. 多項式の積&#10;*&#10;*   vector&lt;complex&lt;double&gt;&gt; a(2*n+1), b(2*n+1);&#10;*&#10;*   auto A = FFT&lt;double&gt;(a).solve();&#10;*   auto B = FFT&lt;double&gt;(b).solve();&#10;*&#10;*   vector&lt;complex&lt;double&gt;&gt; C(A.size());&#10;*   REP(i, C.size()) C[i] = A[i] * B[i];&#10;*&#10;*   auto c = FFT&lt;double&gt;(C).solve(true);&#10;*/&#10;&#10;&#10;template&lt;typename T&gt;&#10;struct FFT {&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(n)&#10;    * @param[in] a_: 多項式の係数&#10;    */&#10;    FFT(const vector&lt;complex&lt;T&gt;&gt;&amp; a_) : a(a_), n(1) {&#10;        while (n &lt; a.size()) n &lt;&lt;= 1;&#10;        a.resize(n);&#10;    }&#10;&#10;    /**&#10;    * @brief FFTの実行. O(nlog n)&#10;    * @param[in] inverse: 逆変換のフラグ.&#10;    * @return FFT or inverse-FFT&#10;    */&#10;    vector&lt;complex&lt;T&gt;&gt; solve(bool inverse = false) {&#10;        return fft(0, 0, inverse);&#10;    }&#10;&#10;private:&#10;    vector&lt;complex&lt;T&gt;&gt; a;&#10;    int n;&#10;    const T PI = acos(-1);&#10;&#10;    vector&lt;complex&lt;T&gt;&gt; fft(int d, int bit, bool inverse) {&#10;        int sz = n &gt;&gt; d;&#10;        if (sz == 1) return {a[bit] / (inverse ? static_cast&lt;T&gt;(n) : 1.0)};&#10;&#10;        auto f0 = fft(d+1, bit, inverse);&#10;        auto f1 = fft(d+1, bit | 1&lt;&lt;d, inverse);&#10;        vector&lt;complex&lt;T&gt;&gt; f(sz);&#10;        for (int i = 0; i &lt; sz; ++i) {&#10;            f[i] = f0[i % (sz / 2)] +&#10;                   std::polar(1.0, 2*PI / sz * i * (inverse ? -1 : 1)) *&#10;                   f1[i % (sz / 2)];&#10;        }&#10;        return f;&#10;    }&#10;};&#10;" description="fft" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="gauss_jordan" value="&#10;/**&#10; * @brief&#10; * ガウスの消去法&#10; * 行列をランクを求めたり、Ax = b を解いたりする&#10; * @author habara-k&#10; * @date 2020/4&#10; * @param[in] mat 行列&#10; * @return int mat のランク&#10; */&#10;&#10;template&lt;class T&gt;&#10;int GaussJordanElimination(vector&lt;vector&lt;T&gt;&gt;&amp; mat) {&#10;    int H = mat.size(), W = mat[0].size(), rank = 0;&#10;    for (int col = 0; col &lt; W; ++col) {&#10;        int pivot = -1;&#10;        for (int row = rank; row &lt; H; ++row) {&#10;            if (mat[row][col] != 0) {&#10;                pivot = row;&#10;                break;&#10;            }&#10;        }&#10;        if (pivot == -1) continue;&#10;        swap(mat[rank], mat[pivot]);&#10;        T topLeft = mat[rank][col];&#10;        for (int c = col; c &lt; W; ++c) {&#10;            mat[rank][c] /= topLeft;&#10;        }&#10;        for (int row = rank+1; row &lt; H; ++row) {&#10;            T ratio = mat[row][col];&#10;            for (int c = col; c &lt; W; ++c)&#10;                mat[row][c] -= ratio * mat[rank][c];&#10;        }&#10;        ++rank;&#10;    }&#10;    return (rank);&#10;}&#10;" description="gauss_jordan" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="matrix" value="&#10;/**&#10; * @brief&#10; * 行列累乗&#10; * @author habara-k&#10; * @date 2020/04/24&#10; * @param[in] a 行列&#10; * @param[in] k 指数&#10; * @return 行列 a^k&#10; *&#10; * @details&#10; * T に渡すのは環であり、operator *, += を定義すること&#10; */&#10;&#10;template&lt;class T&gt;&#10;using Matrix = vector&lt;vector&lt;T&gt;&gt;;&#10;&#10;template&lt;class T&gt;&#10;Matrix&lt;T&gt; operator*(const Matrix&lt;T&gt;&amp; A, const Matrix&lt;T&gt;&amp; B) {&#10;    assert(A[0].size() == B.size());&#10;    int n = A.size(), m = B[0].size(), p = A[0].size();&#10;    Matrix&lt;T&gt; C(n, vector&lt;T&gt;(m));&#10;    for (int i = 0; i &lt; n; ++i)&#10;        for (int j = 0; j &lt; m; ++j)&#10;            for (int k = 0; k &lt; p; ++k)&#10;                C[i][j] += A[i][k] * B[k][j];&#10;    return C;&#10;}&#10;&#10;template&lt;class T&gt;&#10;Matrix&lt;T&gt; pow(Matrix&lt;T&gt; a, ll k) {&#10;    assert(a.size() == a[0].size());&#10;    int n = a.size();&#10;    Matrix&lt;T&gt; ret(n, vector&lt;T&gt;(n));&#10;    for (int i = 0; i &lt; n; ++i) ret[i][i] = 1;&#10;    while (k) {&#10;        if (k &amp; 1) ret = ret * a;&#10;        a = a * a; k &gt;&gt;= 1;&#10;    }&#10;    return ret;&#10;}&#10;" description="matrix" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="crt" value="&#10;/**&#10; * @brief&#10; * 中国式場予定理(CRT)&#10; * m1で割ったあまりがa1, m2で割ったあまりがa2のとき、m1*m2でわったあまりを構築&#10; * @author Md&#10; * @date 2020/04/25&#10; */&#10;&#10;/**&#10; * @return first: 答え, second: modの値&#10; */&#10;pair&lt;ll, ll&gt; crt(ll a1, ll m1, ll a2, ll m2) {&#10;  ll p, q;&#10;  ll g = extended_gcd(m1, m2, p, q);&#10;  if ((a1 - a2) % g) return make_pair(0, -1);&#10;  return make_pair(a1 + m1 * (a2 - a1) / g * p % (m2 / g), m1 * (m2 / g));&#10;}&#10;&#10;/**&#10; * @brief&#10; * 式が複数個ある場合&#10; * @return first: 答え, second: modの値&#10; */&#10;pair&lt;ll, ll&gt; crt(const vector&lt;ll&gt; &amp;a, const vector&lt;ll&gt; &amp;m) {&#10;  ll r = 0, mod = 1;&#10;  REP(i, SZ(a)) {&#10;    ll p, q;&#10;    ll g = extended_gcd(mod, m[i], p, q);&#10;    if ((a[i] - r) % g) return make_pair(0, -1);&#10;    ll tmp = (a[i] - r) / g * p % (m[i] / g);&#10;    r += mod * tmp;&#10;    mod *= m[i] / g;&#10;  }&#10;  return make_pair(r % mod, mod);&#10;}&#10;" description="crt" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rolling_hash_2D" value="&#10;/**&#10;* @brief 2次元文字列のハッシュ化&#10;* @author habara-k&#10;* @date 2020/07/05&#10;*/&#10;&#10;struct RollingHash2D {&#10;    using uint = uint64_t;&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(|vs|)&#10;    * @param[in] vs ハッシュ化する文字列のベクトル(or matrix).&#10;    * @param[in] base1, base2 ハッシュ化に使う基数. RollingHash2D::gen_base で作る.&#10;    * @details 使い方&#10;    *   auto base1 = RollingHash2D::gen_base(),&#10;    *        base2 = RolligHash2D::gen_base();&#10;    *&#10;    *   vector&lt;string&gt; t;&#10;    *   RollingHash2D hash(t, base1, base2);&#10;    */&#10;    template&lt;typename VS&gt;&#10;    RollingHash2D(const VS &amp;vs, uint base1, uint base2) {&#10;        int n = vs.size();&#10;        int m = vs[0].size();&#10;        hash.resize(n + 1);&#10;        for (int i = 0; i &lt;= n; ++i) hash[i].resize(m + 1);&#10;&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            for (int j = 0; j &lt; m; ++j) {&#10;                hash[i + 1][j + 1] = mod(mul(hash[i + 1][j], base2) + vs[i][j]);&#10;            }&#10;        }&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            for (int j = 0; j &lt; m; ++j) {&#10;                hash[i + 1][j + 1] = mod(mul(hash[i][j + 1], base1) + hash[i + 1][j + 1]);&#10;            }&#10;        }&#10;&#10;        pow1.assign(n + 1, 1);&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            pow1[i + 1] = mul(pow1[i], base1);&#10;        }&#10;        pow2.assign(m + 1, 1);&#10;        for (int j = 0; j &lt; m; ++j) {&#10;            pow2[j + 1] = mul(pow2[j], base2);&#10;        }&#10;    }&#10;&#10;    /**&#10;    * @brief ハッシュを計算する. O(1)&#10;    * @param[in] i0, j0, i1, j1 ハッシュを計算したい区間.&#10;    * @return 区間[(i0,j0), (i1,j1)) のハッシュ.&#10;    * @details 使い方&#10;    *   cout &lt;&lt; hash.get(0, 0, t.size(), t[0].size()) &lt;&lt; endl;&#10;    */&#10;    long long get(int i0, int j0, int i1, int j1) {&#10;        uint a = mod(hash[i1][j1] + MASK61 - mul(hash[i1][j0], pow2[j1 - j0]));&#10;        uint b = mod(hash[i0][j1] + MASK61 - mul(hash[i0][j0], pow2[j1 - j0]));&#10;        return mod(a + MASK61 - mul(b, pow1[i1 - i0]));&#10;    }&#10;&#10;    /**&#10;    * @brief 基数を生成する. O(1)&#10;    * @return ランダムな基数.&#10;    * @details 使い方&#10;    *   auto base = RollingHash::gen_base();&#10;    */&#10;    static uint gen_base() {&#10;        mt19937 random{random_device{}()};&#10;        uniform_int_distribution &lt;uint&gt; dist(2, MASK61 - 2);&#10;        return dist(random);&#10;    }&#10;&#10;private:&#10;    vector&lt;vector&lt;uint&gt;&gt; hash;&#10;    vector&lt;uint&gt; pow1, pow2;&#10;    static const uint MASK30 = (1LL &lt;&lt; 30) - 1,&#10;            MASK31 = (1LL &lt;&lt; 31) - 1,&#10;            MASK61 = (1LL &lt;&lt; 61) - 1;&#10;&#10;    static uint mul(uint a, uint b) {&#10;        uint au = a &gt;&gt; 31, ad = a &amp; MASK31,&#10;                bu = b &gt;&gt; 31, bd = b &amp; MASK31;&#10;        uint m = au * bd + ad * bu;&#10;        uint mu = m &gt;&gt; 30, md = m &amp; MASK30;&#10;&#10;        return mod(au * bu * 2 + mu + (md &lt;&lt; 31) + ad * bd);&#10;    }&#10;&#10;    static uint mod(uint x) {&#10;        uint xu = x &gt;&gt; 61, xd = x &amp; MASK61;&#10;        uint ret = xu + xd;&#10;        if (ret &gt;= MASK61) ret -= MASK61;&#10;        return ret;&#10;    }&#10;};&#10;" description="rolling_hash_2D" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="rolling_hash" value="&#10;/**&#10;* @brief 文字列のハッシュ化&#10;* @author habara-k&#10;* @date 2020/04/26&#10;*/&#10;&#10;struct RollingHash {&#10;    using uint = uint64_t;&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(|s|)&#10;    * @param[in] s ハッシュ化する文字列(or vector).&#10;    * @param[in] base ハッシュ化に使う基数. RollingHash::gen_base で作る.&#10;    * @details 使い方&#10;    *   auto base = RollingHash::gen_base();&#10;    *&#10;    *   string t; cin &gt;&gt; t;&#10;    *   RollingHash hash(t, base);&#10;    */&#10;    template&lt;typename S&gt;&#10;    RollingHash(const S&amp; s, uint base) {&#10;        int n = s.size();&#10;        hash.assign(n+1, 0);&#10;        pow.assign(n+1, 1);&#10;        for (int i = 0; i &lt; n; ++i) {&#10;            hash[i+1] = mod(mul(hash[i], base) + s[i]);&#10;            pow[i+1] = mul(pow[i], base);&#10;        }&#10;    }&#10;&#10;    /**&#10;    * @brief ハッシュを計算する. O(1)&#10;    * @param[in] l, r ハッシュを計算したい区間.&#10;    * @return 区間[l, r) のハッシュ.&#10;    * @details 使い方&#10;    *   cout &lt;&lt; hash.get(0, t.size()) &lt;&lt; endl;&#10;    */&#10;    uint get(int l, int r) const {&#10;        return mod(hash[r] + MASK61 - mul(hash[l], pow[r - l]));&#10;    }&#10;&#10;    /**&#10;    * @brief 基数を生成する. O(1)&#10;    * @return ランダムな基数.&#10;    * @details 使い方&#10;    *   auto base = RollingHash::gen_base();&#10;    */&#10;    static uint gen_base() {&#10;        mt19937 random{random_device{}()};&#10;        uniform_int_distribution&lt;uint&gt; dist(2, MASK61-2);&#10;        return dist(random);&#10;    }&#10;&#10;private:&#10;    vector&lt;uint&gt; hash, pow;&#10;    static const uint MASK30 = (1LL&lt;&lt;30)-1,&#10;                      MASK31 = (1LL&lt;&lt;31)-1,&#10;                      MASK61 = (1LL&lt;&lt;61)-1;&#10;&#10;    static uint mul(uint a, uint b) {&#10;        uint au = a &gt;&gt; 31, ad = a &amp; MASK31,&#10;             bu = b &gt;&gt; 31, bd = b &amp; MASK31;&#10;        uint m = au * bd + ad * bu;&#10;        uint mu = m &gt;&gt; 30, md = m &amp; MASK30;&#10;&#10;        return mod(au*bu*2 + mu + (md&lt;&lt;31) + ad*bd);&#10;    }&#10;    static uint mod(uint x) {&#10;        uint xu = x &gt;&gt; 61, xd = x &amp; MASK61;&#10;        uint ret = xu + xd;&#10;        if (ret &gt;= MASK61) ret -= MASK61;&#10;        return ret;&#10;    }&#10;};&#10;" description="rolling_hash" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="manacher" value="&#10;/*&#10; * @brief 文字列の各位置を中心とする回文長をO(|S|)で求める&#10; * @detail 偶数長の回文について同じことをしたいときははabcde -&gt; $a$b$c$d$e$ みたいな変換をして使う&#10; * @author Md&#10; * @date 2020/07/10&#10; */&#10;vi Manacher(string s) {&#10;  int c = 0, n = SZ(s); // c: すでに見つけた回文のうち、右端が最も右に有るようなもの&#10;  vi r(n, 1);&#10;  REP(i, n) {&#10;    int l = c - (i - c);&#10;    if(i + r[l] &lt; c + r[c]) { // 位置cの回文に位置lの回文が含まれていれば、r[l]とr[i]は一致する&#10;      r[i] = r[l];&#10;    } else {&#10;      int j = c + r[c] - i; // cに含まれている部分は大丈夫(そうでなければif節に行くはず&#10;      while(i - j &gt;= 0 &amp;&amp; i + j &lt; n &amp;&amp; s[i-j] == s[i+j]) ++j; // 愚直に求める&#10;      r[i] = j;&#10;      c = i;&#10;    }&#10;  }&#10;  return r;&#10;}&#10;" description="manacher" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="z_algorithm" value="&#10;// GET A[i]: the longest common prefix size of S and S[i:n-1]&#10;template&lt;typename S&gt;&#10;void z_algorithm(const S&amp; s, vector&lt;int&gt;&amp; A) {&#10;    int n = s.size();&#10;    A.resize(n);&#10;    A[0] = n;&#10;    int i = 1, j = 0;&#10;    while (i &lt; n) {&#10;        while (i+j &lt; n &amp;&amp; s[j] == s[i+j]) ++j;&#10;        A[i] = j;&#10;        if (j == 0) { ++i; continue; }&#10;        int k = 1;&#10;        while (i+k &lt; n &amp;&amp; k+A[k] &lt; j) { A[i+k] = A[k]; ++k; }&#10;        i += k; j -= k;&#10;    }&#10;}&#10;" description="z_algorithm" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="persistent_segment_tree" value="&#10;/**&#10;* @brief 完全永続セグメント木&#10;* @author habara-k&#10;* @date 2020/05/04&#10;* @details 使い方&#10;*   build, updateするたびにNode* が返る.&#10;*   これを保存して置いて, 取得時に利用する.&#10;*&#10;*   e.g.&#10;*   vector&lt;vector&lt;int&gt;&gt; g(n) // tree;&#10;*   PersistentSegmentTree&lt;int&gt; segt(&#10;*           sz, [](int a,int b){ return a+b; }, 0);&#10;*&#10;*   // 頂点 -&gt; Node* を保存する.&#10;*   map&lt;int,PersistentSegmentTree&lt;int&gt;::Node*&gt; root;&#10;*&#10;*   function&lt;void(int,int)&gt; dfs = [&amp;](int v, int p) {&#10;*       root[v] = segt.update(root[p],&#10;*               x[v], [](int a){ return a+1; });&#10;*       for (int u : G[v]) {&#10;*           if (u != p) dfs(u, v);&#10;*       }&#10;*   };&#10;*&#10;*   root[-1] = segt.build();&#10;*   dfs(0, -1);&#10;*/&#10;template&lt;typename M&gt;&#10;struct PersistentSegmentTree {&#10;    struct Node {&#10;        Node *l, *r;&#10;        M data;&#10;        Node() : l(nullptr), r(nullptr) {}&#10;    };&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(1)&#10;    * @param[in] n 遅延セグ木のサイズ.&#10;    * @param[in] f モノイドの演算.&#10;    * @param[in] e モノイドの単位元.&#10;    * @details 使い方&#10;    *   e.g. Range Sum&#10;    *   PersistentSegmentTree&lt;int&gt; segt(&#10;    *            n, [](int a,int b){ return a+b; }, 0);&#10;    */&#10;    PersistentSegmentTree(int n, const function&lt;M(M,M)&gt;&amp; f, const M&amp; e) :&#10;            n(n), f(f), e(e) {}&#10;&#10;    /**&#10;    * @brief セグメント木を構築する. O(nlog n)&#10;    * @details 使い方&#10;    *   root[-1] = segt.build();&#10;    */&#10;    Node* build() const {&#10;        return build(0, n);&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した位置に更新クエリを実行する. O(log n)&#10;    * @param[in] root: 作用させるセグ木の根.&#10;    * @param[in] k: 位置k の要素に作用させる.&#10;    * @param[in] q: 値x をq(x) で更新する.&#10;    * @details 使い方&#10;    *   e.g. Add Query&#10;    *   int i, x; // 位置i をx を足したい.&#10;    *   root[v] = segt.update(root[p], i, [&amp;](int a){ return a + x; });&#10;    *&#10;    *   e.g. Update Query&#10;    *   int i, x; // 位置i をx に更新したい.&#10;    *   root[v] = segt.update(root[p], i, [&amp;](int a){ return x; });&#10;    */&#10;    template&lt;typename UpdateQuery&gt;&#10;    Node* update(Node* root, int k, const UpdateQuery&amp; q) const {&#10;        return update(root, k, q, 0, n);&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した区間に取得クエリを実行する. O(log n)&#10;    * @param[in] l, r 区間[l, r) を取得する.&#10;    * @return 取得した値.&#10;    * @details 使い方&#10;    *   e.g. Range Minimum&#10;    *   int l, r; // 区間[l, r) のminを取得したい.&#10;    *   cout &lt;&lt; segt.query(root[v], l, r) &lt;&lt; endl;&#10;    */&#10;    M query(Node* root, int a, int b) const {&#10;        return query(root, a, b, 0, n);&#10;    }&#10;&#10;private:&#10;    const int n;&#10;    const function&lt;M(M,M)&gt; f;&#10;    const M e;&#10;&#10;    Node* _new(const M&amp; data) const {&#10;        auto t = new Node();&#10;        t-&gt;data = data;&#10;        return t;&#10;    }&#10;&#10;    Node* _new(Node* l, Node* r) const {&#10;        auto t = new Node();&#10;        t-&gt;l = l, t-&gt;r = r, t-&gt;data = f(l-&gt;data, r-&gt;data);&#10;        return t;&#10;    }&#10;&#10;    Node* build(int l, int r) const {&#10;        assert(l &lt; r);&#10;        if (l + 1 == r) return _new(e);&#10;        return _new(build(l, (l + r) &gt;&gt; 1), build((l + r) &gt;&gt; 1, r));&#10;    }&#10;&#10;    template&lt;typename UpdateQuery&gt;&#10;    Node* update(Node* t, int k, const UpdateQuery&amp; q, int l, int r) const {&#10;        if (k == l and k + 1 == r) return _new(q(t-&gt;data));&#10;        if (r &lt;= k or k &lt; l) return t;&#10;        return _new(update(t-&gt;l, k, q, l, (l + r) &gt;&gt; 1),&#10;                    update(t-&gt;r, k, q, (l + r) &gt;&gt; 1, r));&#10;    }&#10;&#10;    M query(Node* t, int a, int b, int l, int r) const {&#10;        if (r &lt;= a or b &lt;= l) return e;&#10;        if (a &lt;= l and r &lt;= b) return t-&gt;data;&#10;        return f(query(t-&gt;l, a, b, l, (l + r) &gt;&gt; 1),&#10;                 query(t-&gt;r, a, b, (l + r) &gt;&gt; 1, r));&#10;    }&#10;};&#10;" description="persistent_segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="bit_range_add" value="&#10;/**&#10; * 区間add区間sum&#10; */&#10;&#10;template&lt;typename T&gt;&#10;struct RangeAdd {&#10;  BIT&lt;T&gt; bit1, bit2;&#10;&#10;  RangeAdd(int n): bit1(BIT&lt;T&gt;(n+1)), bit2(BIT&lt;T&gt;(n+1)) {&#10;  }&#10;&#10;  // [l, r)にvalを加算&#10;  void add(int l, int r, T val) {&#10;    bit1.add(l, -l*val);&#10;    bit1.add(r, r*val);&#10;    bit2.add(l, val);&#10;    bit2.add(r, -val);&#10;  }&#10;&#10;  // [0, idx)の和を取得&#10;  T sum(int idx) {&#10;    idx++;&#10;    return bit1.sum(idx) + idx * bit2.sum(idx);&#10;  }&#10;};" description="bit_range_add" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="binary_indexed_tree" value="&#10;template&lt;typename T&gt;&#10;struct BIT {&#10;    vector&lt;T&gt; bit;&#10;    int sz;&#10;    BIT(int n) : sz(n+1), bit(n+1) {}&#10;    void add(int i, T x) {&#10;        i += 1;&#10;        while (i &lt; sz) { bit[i] += x; i += i &amp; -i; }&#10;    }&#10;    T sum(int i) {&#10;        i += 1; T s = 0;&#10;        while (i &gt; 0) { s += bit[i]; i -= i &amp; -i; }&#10;        return s;&#10;    }&#10;};&#10;" description="binary_indexed_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazy_segment_rbst" value="&#10;/**&#10; * @brief&#10; * 列を管理する平衡二分木&#10; * 任意箇所の要素の更新・取得・挿入・削除をO(log n)で行う.&#10; * モノイドが乗る. 区間取得をO(log n) で行う.&#10; * 遅延処理が乗る.&#10; * @author habara-k&#10; * @date 2020/05/05&#10; */&#10;&#10;template&lt;typename M, typename OM = M&gt;&#10;struct LazySegmentRBST {&#10;&#10;    struct Node {&#10;        Node *lch, *rch;&#10;        int sz;&#10;        M data, sum;&#10;        OM lazy;&#10;        Node(const M&amp; data, const OM&amp; lazy) :&#10;            lch(nullptr), rch(nullptr), sz(1),&#10;            data(data), sum(data), lazy(lazy) {}&#10;    };&#10;&#10;    using F = function&lt;M(M,M)&gt;;&#10;    using G = function&lt;M(M,OM,int)&gt;;&#10;    using H = function&lt;OM(OM,OM)&gt;;&#10;&#10;    LazySegmentRBST(const F&amp; f, const G&amp; g, const H&amp; h, M e, OM oe) :&#10;        f(f), g(g), h(h), e(e), oe(oe), root(nullptr) {}&#10;&#10;    /**&#10;    * @brief 配列で初期化する. O(n)&#10;    */&#10;    void build(const vector&lt;M&gt;&amp; v) { root = build(v, 0, v.size()); }&#10;&#10;    /**&#10;    * @brief 木のサイズを返す. O(1)&#10;    */&#10;    inline int size() {&#10;        return size(root);&#10;    }&#10;&#10;    /**&#10;    * @brief 区間update. O(log n)&#10;    * @param[in] a, b: updateする区間&#10;    * @param[in] lazy: 作用の要素&#10;    */&#10;    void update(int a, int b, const OM&amp; lazy) {&#10;        auto p0 = split(root, a);&#10;        auto p1 = split(p0.second, b-a);&#10;        p1.first-&gt;lazy = h(p1.first-&gt;lazy, lazy);&#10;        p1.first = propagate(p1.first);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の取得を行う. O(log n)&#10;    * @param[in] a, b: 取得したい区間&#10;    * @return 取得した値&#10;    */&#10;    M query(int a, int b) {&#10;        auto p0 = split(root, a);&#10;        auto p1 = split(p0.second, b - a);&#10;        p1.first = propagate(p1.first);&#10;        M ret = sum(p1.first);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;        return ret;&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の取得を行う. O(log n)&#10;    * @param[in] i: 取得したい要素のindex&#10;    * @return 取得した値&#10;    */&#10;    M operator[](int i) {&#10;        return query(i, i + 1);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の挿入を行う. O(log n)&#10;    * @param[in] i: 挿入したいindex&#10;    * @param[in] data: 挿入したい値&#10;    */&#10;    void insert(int i, const M&amp; data) {&#10;        auto q = _new(data);&#10;        auto p = split(root, i);&#10;        root = merge(merge(p.first, q), p.second);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の削除を行う. O(log n)&#10;    * @param[in] i: 挿入したいindex&#10;    */&#10;    M erase(int i) {&#10;        auto p = split(root, i);&#10;        auto q = split(p.second, 1);&#10;        M ret = q.first-&gt;data;&#10;        root = merge(p.first, q.second);&#10;        return ret;&#10;    }&#10;&#10;    /**&#10;    * @brief vector みたいに出力.&#10;    */&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,&#10;                               LazySegmentRBST&amp; tr) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; tr.size(); ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; tr[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;&#10;protected:&#10;    Node* root;&#10;&#10;    inline int size(Node* t) const { return t ? t-&gt;sz : 0; }&#10;    inline M sum(Node* t) const { return t ? t-&gt;sum : e; }&#10;    inline OM lazy(Node* t) const { return t ? t-&gt;lazy : oe; }&#10;&#10;    Node* merge(Node *l, Node *r) {&#10;        if (!l) return r;&#10;        if (!r) return l;&#10;        if (xor128() % (size(l) + size(r)) &lt; size(l)) {&#10;            l = propagate(l);&#10;            l-&gt;rch = merge(l-&gt;rch, r);&#10;            return modify(l);&#10;        } else {&#10;            r = propagate(r);&#10;            r-&gt;lch = merge(l, r-&gt;lch);&#10;            return modify(r);&#10;        }&#10;    }&#10;&#10;    pair&lt;Node*, Node*&gt; split(Node* t, int k) {&#10;        if (!t) return {t, t};&#10;        t = propagate(t);&#10;        if (k &gt; size(t-&gt;lch)) {&#10;            auto p = split(t-&gt;rch, k-size(t-&gt;lch)-1);&#10;            t-&gt;rch = p.first;&#10;            return {modify(t), p.second};&#10;        } else {&#10;            auto p = split(t-&gt;lch, k);&#10;            t-&gt;lch = p.second;&#10;            return {p.first, modify(t)};&#10;        }&#10;    }&#10;&#10;private:&#10;    const F f;&#10;    const G g;&#10;    const H h;&#10;    const M e;&#10;    const OM oe;&#10;&#10;    inline int xor128() {&#10;        static int x = 123456789;&#10;        static int y = 362436069;&#10;        static int z = 521288629;&#10;        static int w = 88675123;&#10;        int t;&#10;&#10;        t = x ^ (x &lt;&lt; 11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;    }&#10;&#10;    Node* build(const vector&lt;M&gt;&amp; v, int l, int r) {&#10;        if (l + 1 &gt;= r) return _new(v[l]);&#10;        return merge(build(v, l, (l + r) &gt;&gt; 1),&#10;                     build(v, (l + r) &gt;&gt; 1, r));&#10;    }&#10;&#10;    inline Node* _new(const M&amp; data) const { return new Node(data, oe); }&#10;&#10;    inline Node* modify(Node *t) {&#10;        t-&gt;sz = size(t-&gt;lch) + size(t-&gt;rch) + 1;&#10;        t-&gt;sum = f(f(sum(t-&gt;lch), t-&gt;data), sum(t-&gt;rch));&#10;        return t;&#10;    }&#10;&#10;    Node* propagate(Node* t) {&#10;        if (!t) return t;&#10;        if (lazy(t) == oe) return t;&#10;        if (t-&gt;lch != nullptr) {&#10;            t-&gt;lch-&gt;lazy = h(lazy(t-&gt;lch), lazy(t));&#10;            t-&gt;lch-&gt;sum = g(sum(t-&gt;lch), lazy(t), size(t-&gt;lch));&#10;        }&#10;        if (t-&gt;rch != nullptr) {&#10;            t-&gt;rch-&gt;lazy = h(lazy(t-&gt;rch), lazy(t));&#10;            t-&gt;rch-&gt;sum = g(sum(t-&gt;rch), lazy(t), size(t-&gt;rch));&#10;        }&#10;        t-&gt;data = g(t-&gt;data, lazy(t), 1);&#10;        t-&gt;lazy = oe;&#10;        return modify(t);&#10;    }&#10;};&#10;" description="lazy_segment_rbst" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="randomized_binary_search_tree" value="&#10;/**&#10; * @brief&#10; * 列を管理する平衡二分木&#10; * 任意箇所の要素の更新・取得・挿入・削除をO(log n)で行う.&#10; * @author habara-k&#10; * @date 2020/05/05&#10; */&#10;&#10;template&lt;typename T&gt;&#10;struct RandomizedBinarySearchTree {&#10;&#10;    struct Node {&#10;        Node *lch, *rch;&#10;        int sz;&#10;        T data;&#10;        Node(const T&amp; data) :&#10;                lch(nullptr), rch(nullptr), sz(1),&#10;                data(data) {}&#10;    };&#10;&#10;    RandomizedBinarySearchTree() : root(nullptr) {}&#10;&#10;    /**&#10;    * @brief 配列で初期化する. O(n)&#10;    */&#10;    void build(const vector&lt;T&gt;&amp; v) { root = build(v, 0, v.size()); }&#10;&#10;    /**&#10;    * @brief 木のサイズを返す. O(1)&#10;    */&#10;    inline int size() {&#10;        return size(root);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の更新を行う. O(log n)&#10;    * @param[in] i: 要素のindex&#10;    * @param[in] q: x をq(x) で更新する.&#10;    */&#10;    template&lt;class UpdateQuery&gt;&#10;    void update(int i, const UpdateQuery&amp; q) {&#10;        auto p0 = split(root, i);&#10;        auto p1 = split(p0.second, 1);&#10;        p1.first-&gt;data = q(p1.first-&gt;data);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の取得を行う. O(log n)&#10;    * @param[in] i: 取得したい要素のindex&#10;    * @return 取得した値&#10;    */&#10;    T operator[](int i) {&#10;        auto p0 = split(root, i);&#10;        auto p1 = split(p0.second, 1);&#10;        T ret = p1.first-&gt;data;&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;        return ret;&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の挿入を行う. O(log n)&#10;    * @param[in] i: 挿入したいindex&#10;    * @param[in] data: 挿入したい値&#10;    */&#10;    void insert(int i, const T&amp; data) {&#10;        auto q = _new(data);&#10;        auto p = split(root, i);&#10;        root = merge(merge(p.first, q), p.second);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の削除を行う. O(log n)&#10;    * @param[in] i: 挿入したいindex&#10;    */&#10;    T erase(int i) {&#10;        auto p = split(root, i);&#10;        auto q = split(p.second, 1);&#10;        T ret = q.first-&gt;data;&#10;        root = merge(p.first, q.second);&#10;        return ret;&#10;    }&#10;&#10;    /**&#10;    * @brief vector みたいに出力.&#10;    */&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,&#10;                               RandomizedBinarySearchTree&amp; tr) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; tr.size(); ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; tr[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;&#10;protected:&#10;    Node* root;&#10;&#10;    inline int size(Node* t) const { return t ? t-&gt;sz : 0; }&#10;&#10;    Node* merge(Node *l, Node *r) {&#10;        if (!l) return r;&#10;        if (!r) return l;&#10;        if (xor128() % (size(l) + size(r)) &lt; size(l)) {&#10;            l-&gt;rch = merge(l-&gt;rch, r);&#10;            return modify(l);&#10;        } else {&#10;            r-&gt;lch = merge(l, r-&gt;lch);&#10;            return modify(r);&#10;        }&#10;    }&#10;&#10;    pair&lt;Node*, Node*&gt; split(Node* t, int k) {&#10;        if (!t) return {t, t};&#10;        if (k &gt; size(t-&gt;lch)) {&#10;            auto p = split(t-&gt;rch, k-size(t-&gt;lch)-1);&#10;            t-&gt;rch = p.first;&#10;            return {modify(t), p.second};&#10;        } else {&#10;            auto p = split(t-&gt;lch, k);&#10;            t-&gt;lch = p.second;&#10;            return {p.first, modify(t)};&#10;        }&#10;    }&#10;&#10;private:&#10;    inline int xor128() {&#10;        static int x = 123456789;&#10;        static int y = 362436069;&#10;        static int z = 521288629;&#10;        static int w = 88675123;&#10;        int t;&#10;&#10;        t = x ^ (x &lt;&lt; 11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;    }&#10;&#10;    Node* build(const vector&lt;T&gt;&amp; v, int l, int r) {&#10;        if (l + 1 &gt;= r) return _new(v[l]);&#10;        return merge(build(v, l, (l + r) &gt;&gt; 1),&#10;                     build(v, (l + r) &gt;&gt; 1, r));&#10;    }&#10;&#10;    inline Node* _new(const T&amp; data) const { return new Node(data); }&#10;&#10;    inline Node* modify(Node *t) {&#10;        t-&gt;sz = size(t-&gt;lch) + size(t-&gt;rch) + 1;&#10;        return t;&#10;    }&#10;};&#10;" description="randomized_binary_search_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segment_rbst" value="&#10;/**&#10; * @brief&#10; * 列を管理する平衡二分木&#10; * 任意箇所の要素の更新・取得・挿入・削除をO(log n)で行う.&#10; * モノイドが乗る. 区間取得をO(log n) で行う.&#10; * @author habara-k&#10; * @date 2020/05/05&#10; * @details veirfy: https://code-festival-2014-exhibition-open.contest.atcoder.jp/tasks/code_festival_exhibition_b&#10; */&#10;&#10;template&lt;typename M&gt;&#10;struct SegmentRBST {&#10;&#10;    struct Node {&#10;        Node *lch, *rch;&#10;        int sz;&#10;        M data, sum;&#10;        Node(const M&amp; data) :&#10;                lch(nullptr), rch(nullptr), sz(1),&#10;                data(data), sum(data) {}&#10;    };&#10;&#10;    using F = function&lt;M(M,M)&gt;;&#10;&#10;    SegmentRBST(const F&amp; f, M e) :&#10;        f(f), e(e), root(nullptr) {}&#10;&#10;    /**&#10;    * @brief 配列で初期化する. O(n)&#10;    */&#10;    void build(const vector&lt;M&gt;&amp; v) { root = build(v, 0, v.size()); }&#10;&#10;    /**&#10;    * @brief 木のサイズを返す. O(1)&#10;    */&#10;    inline int size() {&#10;        return size(root);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の更新を行う. O(log n)&#10;    * @param[in] i: 要素のindex&#10;    * @param[in] q: x をq(x) で更新する.&#10;    */&#10;    template&lt;class UpdateQuery&gt;&#10;    void update(int i, const UpdateQuery&amp; q) {&#10;        auto p0 = split(root, i);&#10;        auto p1 = split(p0.second, 1);&#10;        p1.first-&gt;data = q(p1.first-&gt;data);&#10;        modify(p1.first);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の取得を行う. O(log n)&#10;    * @param[in] a, b: 取得したい区間&#10;    * @return 取得した値&#10;    */&#10;    M query(int a, int b) {&#10;        auto p0 = split(root, a);&#10;        auto p1 = split(p0.second, b - a);&#10;        M ret = sum(p1.first);&#10;        root = merge(p0.first, merge(p1.first, p1.second));&#10;        return ret;&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の取得を行う. O(log n)&#10;    * @param[in] i: 取得したい要素のindex&#10;    * @return 取得した値&#10;    */&#10;    M operator[](int i) {&#10;        return query(i, i + 1);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の挿入を行う. O(log n)&#10;    * @param[in] i: 挿入したいindex&#10;    * @param[in] data: 挿入したい値&#10;    */&#10;    void insert(int i, const M&amp; data) {&#10;        auto q = _new(data);&#10;        auto p = split(root, i);&#10;        root = merge(merge(p.first, q), p.second);&#10;    }&#10;&#10;    /**&#10;    * @brief 要素の削除を行う. O(log n)&#10;    * @param[in] i: 挿入したいindex&#10;    */&#10;    M erase(int i) {&#10;        auto p = split(root, i);&#10;        auto q = split(p.second, 1);&#10;        M ret = q.first-&gt;data;&#10;        root = merge(p.first, q.second);&#10;        return ret;&#10;    }&#10;&#10;    /**&#10;    * @brief vector みたいに出力.&#10;    */&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os,&#10;                               SegmentRBST&amp; tr) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; tr.size(); ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; tr[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;&#10;protected:&#10;    Node* root;&#10;&#10;    inline int size(Node* t) const { return t ? t-&gt;sz : 0; }&#10;    inline M sum(Node* t) const { return t ? t-&gt;sum : e; }&#10;&#10;    Node* merge(Node *l, Node *r) {&#10;        if (!l) return r;&#10;        if (!r) return l;&#10;        if (xor128() % (size(l) + size(r)) &lt; size(l)) {&#10;            l-&gt;rch = merge(l-&gt;rch, r);&#10;            return modify(l);&#10;        } else {&#10;            r-&gt;lch = merge(l, r-&gt;lch);&#10;            return modify(r);&#10;        }&#10;    }&#10;&#10;    pair&lt;Node*, Node*&gt; split(Node* t, int k) {&#10;        if (!t) return {t, t};&#10;        if (k &gt; size(t-&gt;lch)) {&#10;            auto p = split(t-&gt;rch, k-size(t-&gt;lch)-1);&#10;            t-&gt;rch = p.first;&#10;            return {modify(t), p.second};&#10;        } else {&#10;            auto p = split(t-&gt;lch, k);&#10;            t-&gt;lch = p.second;&#10;            return {p.first, modify(t)};&#10;        }&#10;    }&#10;&#10;private:&#10;    const F f;&#10;    const M e;&#10;&#10;    inline int xor128() {&#10;        static int x = 123456789;&#10;        static int y = 362436069;&#10;        static int z = 521288629;&#10;        static int w = 88675123;&#10;        int t;&#10;&#10;        t = x ^ (x &lt;&lt; 11);&#10;        x = y;&#10;        y = z;&#10;        z = w;&#10;        return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));&#10;    }&#10;&#10;    Node* build(const vector&lt;M&gt;&amp; v, int l, int r) {&#10;        if (l + 1 &gt;= r) return _new(v[l]);&#10;        return merge(build(v, l, (l + r) &gt;&gt; 1),&#10;                     build(v, (l + r) &gt;&gt; 1, r));&#10;    }&#10;&#10;    inline Node* _new(const M&amp; data) const { return new Node(data); }&#10;&#10;    inline Node* modify(Node *t) {&#10;        t-&gt;sz = size(t-&gt;lch) + size(t-&gt;rch) + 1;&#10;        t-&gt;sum = f(f(sum(t-&gt;lch), t-&gt;data), sum(t-&gt;rch));&#10;        return t;&#10;    }&#10;};&#10;" description="segment_rbst" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="weighted_union_find" value="&#10;template&lt;typename A&gt;&#10;struct WeightedUnionFind&#10;{&#10;    vector&lt;int&gt; par, sz;&#10;    vector&lt;A&gt; data;     // data[x]: diff from root to x&#10;    WeightedUnionFind(int n, A e=0) :&#10;        par(n), sz(n, 1), data(n, e) {&#10;        for (int i = 0; i &lt; n; ++i) par[i] = i;&#10;    }&#10;&#10;    int root(int x) {&#10;        if (par[x] == x) return x;&#10;        int r = root(par[x]);&#10;        data[x] += data[par[x]];&#10;        return par[x] = r;&#10;    }&#10;&#10;    A weight(int x) {&#10;        root(x);&#10;        return data[x];&#10;    }&#10;&#10;    A diff(int x, int y) {&#10;        // diff from x to y&#10;        return data[y] - data[x];&#10;    }&#10;&#10;    void merge(int x, int y, A w) {&#10;        // merge so that &quot;diff from x to y&quot; will be w.&#10;        w += weight(x); w -= weight(y);&#10;        x = root(x); y = root(y);&#10;        if (x == y) return;&#10;        if (sz[x] &lt; sz[y]) swap(x, y), w = -w;&#10;        par[y] = x;&#10;        sz[x] += sz[y];&#10;        sz[y] = 0;&#10;        data[y] = w;&#10;    }&#10;&#10;    bool issame(int x, int y) {&#10;        return root(x) == root(y);&#10;    }&#10;};&#10;" description="weighted_union_find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="union_find" value="&#10;struct UnionFind&#10;{&#10;    vector&lt;int&gt; par, sz;&#10;    UnionFind(int n) : par(n), sz(n, 1) {&#10;        for (int i = 0; i &lt; n; ++i) par[i] = i;&#10;    }&#10;    int root(int x) {&#10;        if (par[x] == x) return x;&#10;        return par[x] = root(par[x]);&#10;    }&#10;    void merge(int x, int y) {&#10;        x = root(x);&#10;        y = root(y);&#10;        if (x == y) return;&#10;        if (sz[x] &lt; sz[y]) swap(x, y);&#10;        par[y] = x;&#10;        sz[x] += sz[y];&#10;        sz[y] = 0;&#10;    }&#10;    bool issame(int x, int y) {&#10;        return root(x) == root(y);&#10;    }&#10;    int size(int x) {&#10;        return sz[root(x)];&#10;    }&#10;};&#10;" description="union_find" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="lazy_segment_tree" value="&#10;/**&#10;* @brief 遅延セグメント木&#10;* @author habara-k&#10;* @date 2020/04/26&#10;*/&#10;&#10;template&lt;typename M, typename OM = M&gt;&#10;struct LazySegmentTree {&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(n)&#10;    * @param[in] n 遅延セグ木のサイズ.&#10;    * @param[in] f 要素モノイドの演算.&#10;    * @param[in] g 要素に作用素を作用させる演算.&#10;    * @param[in] h 作用素モノイドの演算.&#10;    * @param[in] e 要素モノイドの単位元.&#10;    * @param[in] oe 作用素モノイドの単位元.&#10;    * @details 使い方&#10;    *   e.g. Range Add Range Sum&#10;    *   LazySegmentTree&lt;int&gt; segt(&#10;    *            n,&#10;    *            [](int a,int b){ return a+b; },&#10;    *            [](int a,int b,int w){ return a + b*w; },&#10;    *            [](int a,int b){ return a+b; },&#10;    *            0, 0);&#10;    *               // 全て単位元で初期化される.&#10;    */&#10;    LazySegmentTree(&#10;            int n,&#10;            const function&lt;M(M,M)&gt;&amp; f,&#10;            const function&lt;M(M,OM,int)&gt;&amp; g,&#10;            const function&lt;OM(OM,OM)&gt;&amp; h,&#10;            const M&amp; e, const OM&amp; oe&#10;            ) : n(n), f(f), g(g), h(h), e(e), oe(oe) {&#10;        sz = 1;&#10;        while (sz &lt; n) sz &lt;&lt;= 1;&#10;        data.assign(2 * sz, e);&#10;        lazy.assign(2 * sz, oe);&#10;    }&#10;&#10;    /**&#10;    * @brief 全体に初期値を入れる. O(n)&#10;    * @param[in] v 要素モノイドのvector. 初期化する.&#10;    * @details 使い方&#10;    *   segt.build(vector&lt;int&gt;(n, INF));&#10;    */&#10;    void build(const vector&lt;M&gt;&amp; v) {&#10;        assert(v.size() &lt;= n);&#10;        for (int i = 0; i &lt; v.size(); ++i) {&#10;            data[i + sz] = v[i];&#10;        }&#10;        for (int i = sz-1; i &gt; 0; --i) {&#10;            data[i] = f(data[2 * i], data[2 * i + 1]);&#10;        }&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した区間に作用素x を作用させる. O(log n)&#10;    * @param[in] l, r 区間[l, r) に作用させる.&#10;    * @param[in] x 作用素モノイドの元.&#10;    * @details 使い方&#10;    *   e.g. Range Update&#10;    *   int l, r, x; // 区間[l, r) をx に更新したい.&#10;    *   segt.update(l, r, x);&#10;    */&#10;    void update(int a, int b, const OM&amp; x) {&#10;        update(a, b, x, 1, 0, sz);&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した区間に取得クエリを実行する. O(log n)&#10;    * @param[in] l, r 区間[l, r) を取得する.&#10;    * @return 取得した値.&#10;    * @details 使い方&#10;    *   e.g. Range Minimum&#10;    *   int l, r; // 区間[l, r) のminを取得したい.&#10;    *   cout &lt;&lt; segt.query(l, r) &lt;&lt; endl;&#10;    */&#10;    M query(int a, int b) {&#10;        return query(a, b, 1, 0, sz);&#10;    }&#10;&#10;    /**&#10;    * @brief 指定したindexの要素を取得. O(1)&#10;    * @param[in] i 取得したい要素のindex&#10;    * @return 取得した値.&#10;    */&#10;    M operator[](int i) {&#10;        return query(i, i + 1);&#10;    }&#10;&#10;    /**&#10;    * @brief vector みたいに出力.&#10;    */&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, LazySegmentTree&amp; s) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; s.n; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; s[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;&#10;private:&#10;&#10;    int n, sz;&#10;    vector&lt;M&gt; data;&#10;    vector&lt;OM&gt; lazy;&#10;    const function&lt;M(M,M)&gt; f;&#10;    const function&lt;M(M,OM,int)&gt; g;&#10;    const function&lt;OM(OM,OM)&gt; h;&#10;    const M e;&#10;    const OM oe;&#10;&#10;    void propagate(int k, int len) {&#10;        if (lazy[k] == oe) return;&#10;        if (k &lt; sz) {&#10;            lazy[2 * k    ] = h(lazy[2 * k    ], lazy[k]);&#10;            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);&#10;        }&#10;        data[k] = g(data[k], lazy[k], len);&#10;        lazy[k] = oe;&#10;    }&#10;&#10;    void update(int a, int b, const OM&amp; x, int k, int l, int r) {&#10;        propagate(k, r - l);&#10;        if (r &lt;= a or b &lt;= l) return;&#10;        else if (a &lt;= l and r &lt;= b) {&#10;            lazy[k] = h(lazy[k], x);&#10;            propagate(k, r - l);&#10;        } else {&#10;            update(a, b, x, 2 * k,     l, (l + r) &gt;&gt; 1);&#10;            update(a, b, x, 2 * k + 1, (l + r) &gt;&gt; 1, r);&#10;            data[k] = f(data[2 * k], data[2 * k + 1]);&#10;        }&#10;    }&#10;&#10;    M query(int a, int b, int k, int l, int r) {&#10;        propagate(k, r - l);&#10;        if (r &lt;= a or b &lt;= l) return e;&#10;        else if (a &lt;= l and r &lt;= b) return data[k];&#10;        else return f(&#10;                query(a, b, 2 * k,     l, (l + r) &gt;&gt; 1),&#10;                query(a, b, 2 * k + 1, (l + r) &gt;&gt; 1, r));&#10;    }&#10;};&#10;" description="lazy_segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="multi_set" value="&#10;/**&#10; * @brief&#10; * 常に昇順にソートされた配列（マルチセット）&#10; * 任意箇所の要素の更新・取得・挿入・削除をO(log n)で行う.&#10; * 昇順を保ったまま値の挿入・削除をO(log n)で行う.&#10; * @author habara-k&#10; * @date 2020/05/05&#10; * @details verify: https://arc033.contest.atcoder.jp/tasks/arc033_3&#10; */&#10;&#10;template&lt;typename T&gt;&#10;struct MultiSet : RandomizedBinarySearchTree&lt;T&gt; {&#10;    using RBST = RandomizedBinarySearchTree&lt;T&gt;;&#10;    using Node = typename RBST::Node;&#10;&#10;    MultiSet() : RBST() {}&#10;&#10;    /**&#10;    * @brief 値の挿入を行う. O(log n)&#10;    * @param[in] key: 要素の値&#10;    */&#10;    void insert_key(const T&amp; key) {&#10;        RBST::insert(lower_bound(this-&gt;root, key), key);&#10;    }&#10;&#10;    /**&#10;    * @brief 値の削除を行う. O(log n)&#10;    * @param[in] key: 要素の値&#10;    */&#10;    void erase_key(const T&amp; key) {&#10;        if (count(this-&gt;root, key) == 0) return;&#10;        RBST::erase(lower_bound(this-&gt;root, key));&#10;    }&#10;&#10;private:&#10;    int lower_bound(Node *t, const T&amp; key) {&#10;        if (!t) return 0;&#10;        if (key &lt;= t-&gt;data) return lower_bound(t-&gt;lch, key);&#10;        return lower_bound(t-&gt;rch, key) + RBST::size(t-&gt;lch) + 1;&#10;    }&#10;&#10;    int upper_bound(Node *t, const T&amp; key) {&#10;        if (!t) return 0;&#10;        if (key &lt; t-&gt;data) return upper_bound(t-&gt;lch, key);&#10;        return upper_bound(t-&gt;rch, key) + RBST::size(t-&gt;lch) + 1;&#10;    }&#10;&#10;    int count(Node *t, const T&amp; key) {&#10;        return upper_bound(t, key) - lower_bound(t, key);&#10;    }&#10;};&#10;&#10;" description="multi_set" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="segment_tree" value="&#10;/**&#10;* @brief セグメント木&#10;* @author habara-k, Md&#10;* @date 2020/06/17&#10;*/&#10;&#10;template&lt;typename M&gt;&#10;struct SegmentTree {&#10;&#10;    /**&#10;    * @brief コンストラクタ. O(n)&#10;    * @param[in] n セグ木のサイズ.&#10;    * @param[in] f モノイドの演算(query).&#10;    * @param[in] g モノイドの演算(update).&#10;    * @param[in] e モノイドの単位元.&#10;    * @details 使い方&#10;    *   e.g. Update and Range Minimum&#10;    *   SegmentTree&lt;int&gt; segt(&#10;    *            n,&#10;    *            [](int a,int b){ return min(a+b); },&#10;    *            [](int a, int b){ return b; },&#10;    *            INF);&#10;    *               // 全て単位元で初期化される.&#10;    */&#10;    SegmentTree(&#10;            int n,&#10;            const function&lt;M(M,M)&gt;&amp; f,&#10;            const function&lt;M(M, M)&gt;&amp; g,&#10;            const M&amp; e) : n(n), f(f), g(g), e(e) {&#10;        sz = 1;&#10;        while (sz &lt; n) sz &lt;&lt;= 1;&#10;        data.assign(2 * sz, e);&#10;    }&#10;&#10;    /**&#10;    * @brief 全体に初期値を入れる. O(n)&#10;    * @param[in] v 要素モノイドのvector. 初期化する.&#10;    * @details 使い方&#10;    *   segt.build(vector&lt;int&gt;(n, 0));&#10;    */&#10;    void build(const vector&lt;M&gt;&amp; v) {&#10;        assert(v.size() &lt;= n);&#10;        for (int i = 0; i &lt; v.size(); ++i) {&#10;            data[i + sz] = v[i];&#10;        }&#10;        for (int i = sz-1; i &gt; 0; --i) {&#10;            data[i] = f(data[2 * i], data[2 * i + 1]);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * @brief 指定した位置に更新クエリを実行する O(log n)&#10;     * @param[in] idx 位置idxに作用させる&#10;     * @param[in] val 値xをg(data[idx+sz], val)で更新する&#10;     */&#10;    void update(int idx, M val) {&#10;      idx += sz;&#10;      data[idx] = g(data[idx], val);&#10;      while(idx &gt;&gt;= 1) {&#10;        data[idx] = f(data[2*idx], data[2*idx+1]);&#10;      }&#10;    }&#10;&#10;    /**&#10;    * @brief 指定した区間に取得クエリを実行する. O(log n)&#10;    * @param[in] l, r 区間[l, r) を取得する.&#10;    * @return 取得した値.&#10;    * @details 使い方&#10;    *   e.g. Range Minimum&#10;    *   int l, r; // 区間[l, r) のminを取得したい.&#10;    *   cout &lt;&lt; segt.query(l, r) &lt;&lt; endl;&#10;    */&#10;    M query(int a, int b) const {&#10;        return query(a, b, 1, 0, sz);&#10;    }&#10;&#10;    /**&#10;    * @brief 指定したindexの要素を取得. O(1)&#10;    * @param[in] i 取得したい要素のindex&#10;    * @return 取得した値.&#10;    */&#10;    M operator[](int k) const {&#10;        return data[k + sz];&#10;    }&#10;&#10;    /**&#10;    * @brief vector みたいに出力.&#10;    */&#10;    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, SegmentTree&amp; s) {&#10;        os &lt;&lt; &quot;[&quot;;&#10;        for (int i = 0; i &lt; s.n; ++i) {&#10;            if (i) os &lt;&lt; &quot; &quot;;&#10;            os &lt;&lt; s[i];&#10;        }&#10;        return os &lt;&lt; &quot;]&quot;;&#10;    }&#10;&#10;private:&#10;    int n, sz;&#10;    vector&lt;M&gt; data;&#10;    const function&lt;M(M,M)&gt; f, g;&#10;    const M e;&#10;&#10;    M query(int a, int b, int k, int l, int r) const {&#10;        if (r &lt;= a || b &lt;= l) {&#10;            return e;&#10;        } else if (a &lt;= l &amp;&amp; r &lt;= b) {&#10;            return data[k];&#10;        } else {&#10;            return f(query(a,b,2*k,  l,(l+r)/2),&#10;                     query(a,b,2*k+1,(l+r)/2,r));&#10;        }&#10;    }&#10;};&#10;" description="segment_tree" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
  <template name="convex_hull_trick" value="&#10;/**&#10; * @brief&#10; * ax + b の最小値を管理&#10; * @author habara-k&#10; * @date 2020/05/24&#10; * @verify https://onlinejudge.u-aizu.ac.jp/services/review.html#rupc2014_whiteboard/4508173&#10; */&#10;&#10;template&lt;typename T&gt;&#10;struct ConvexHullTrick {&#10;&#10;    /**&#10;    * @brief コンストラクタ O(n)&#10;    * @param[in] n: 追加する線分の上限&#10;    */&#10;    ConvexHullTrick(int n) : deq(n), s(0), t(0), prev(numeric_limits&lt;T&gt;::min()) {}&#10;&#10;    /**&#10;    * @brief 追加クエリ ならしO(1)&#10;    * @param[in] a, b: ax + b を追加&#10;    */&#10;    void insert(T a, T b) {&#10;        Line l = {a, b};&#10;        while (t - s &gt;= 2 and check(deq[t - 2], deq[t - 1], l)) --t;&#10;        deq[t++] = l;&#10;    }&#10;&#10;    /**&#10;    * @brief 取得クエリ ならしO(1)&#10;    * @param[in] x: xにおける最小値を返す&#10;    * @details x は昇順に呼ぶこと&#10;    */&#10;    T query(T x) {&#10;        assert(prev &lt;= x);&#10;        prev = x;&#10;        while (t - s &gt;= 2 and f(deq[s], x) &gt;= f(deq[s + 1], x)) ++s;&#10;        return f(deq[s], x);&#10;    }&#10;&#10;private:&#10;    struct Line {&#10;        T a, b;&#10;    };&#10;    vector&lt;Line&gt; deq;&#10;    int s, t;&#10;    T prev;&#10;&#10;    bool check(const Line&amp; l1, const Line&amp; l2, const Line&amp; l3) const {&#10;        return (l2.a - l1.a) * (l3.b - l2.b) &gt;= (l2.b - l1.b) * (l3.a - l2.a);&#10;    }&#10;    T f(Line&amp; l, T x) const {&#10;        return l.a * x + l.b;&#10;    }&#10;};&#10;&#10;&#10;" description="convex_hull_trick" toReformat="true" toShortenFQNames="true">
    <context>
      <option name="cpp" value="true" />
    </context>
  </template>
</templateSet>
